// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Types = require("../src/Types.bs.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var ConcreteSyntaxLexer = require("../src/ConcreteSyntaxLexer.bs.js");
var ConcreteSyntaxParser = require("../src/ConcreteSyntaxParser.bs.js");

Jest.describe("ConcreteSyntaxParser", (function (param) {
        var expectParse = function (parser, str, tm) {
          return Jest.test("parse '" + (str + "'"), (function (param) {
                        var tm$prime = Curry._2(parser, ConcreteSyntaxLexer.read, Lexing.from_string(str));
                        return Jest.Expect[/* toEqual */12](tm, Jest.Expect[/* expect */0](tm$prime));
                      }));
        };
        var expectRoundTrip = function (parser, str) {
          return Jest.test("round trip '" + (str + "'"), (function (param) {
                        var re = Curry._2(parser, ConcreteSyntaxLexer.read, Lexing.from_string(str));
                        return Jest.Expect[/* toEqual */12](str, Jest.Expect[/* expect */0](Types.ConcreteSyntaxDescription[/* show_regex */7](re)));
                      }));
        };
        expectParse(ConcreteSyntaxParser.regex__test, "\"foo\"", /* :: */[
              /* ReString */Block.__(0, ["foo"]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "[a-z]", /* :: */[
              /* ReSet */Block.__(2, ["a-z"]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "[a-zA-Z]", /* :: */[
              /* ReSet */Block.__(2, ["a-zA-Z"]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "[a-z][A-Z]", /* :: */[
              /* ReSet */Block.__(2, ["a-z"]),
              /* :: */[
                /* ReSet */Block.__(2, ["A-Z"]),
                /* [] */0
              ]
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "\"foo\"*", /* :: */[
              /* ReStar */Block.__(3, [/* ReString */Block.__(0, ["foo"])]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "\"foo\"+", /* :: */[
              /* RePlus */Block.__(4, [/* ReString */Block.__(0, ["foo"])]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "\"foo\"?", /* :: */[
              /* ReOption */Block.__(5, [/* ReString */Block.__(0, ["foo"])]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "\"\\\\\"", /* :: */[
              /* ReString */Block.__(0, ["\\"]),
              /* [] */0
            ]);
        expectParse(ConcreteSyntaxParser.regex__test, "\"\\b\"", /* :: */[
              /* ReClass */Block.__(1, ["\\b"]),
              /* [] */0
            ]);
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "\"foo\"");
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "[a-z]");
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "[a-zA-Z]");
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "[a-z][A-Z]");
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "\"foo\"*");
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "\"foo\"+");
        expectRoundTrip(ConcreteSyntaxParser.regex__test, "\"foo\"?");
        expectParse(ConcreteSyntaxParser.terminal_rule__test, "TERMINAL := \"foo\"", /* TerminalRule */[
              "TERMINAL",
              /* :: */[
                /* ReString */Block.__(0, ["foo"]),
                /* [] */0
              ]
            ]);
        expectParse(ConcreteSyntaxParser.terminal_rule__test, "TERMINAL := \"->\"", /* TerminalRule */[
              "TERMINAL",
              /* :: */[
                /* ReString */Block.__(0, ["->"]),
                /* [] */0
              ]
            ]);
        expectParse(ConcreteSyntaxParser.terminal_rule__test, "ID := [a-zA-Z][a-zA-Z0-9_]*", /* TerminalRule */[
              "ID",
              /* :: */[
                /* ReSet */Block.__(2, ["a-zA-Z"]),
                /* :: */[
                  /* ReStar */Block.__(3, [/* ReSet */Block.__(2, ["a-zA-Z0-9_"])]),
                  /* [] */0
                ]
              ]
            ]);
        expectParse(ConcreteSyntaxParser.terminal_rule__test, "SPACE := [ ]+", /* TerminalRule */[
              "SPACE",
              /* :: */[
                /* RePlus */Block.__(4, [/* ReSet */Block.__(2, [" "])]),
                /* [] */0
              ]
            ]);
        expectParse(ConcreteSyntaxParser.capture_number, "$2", 2);
        expectParse(ConcreteSyntaxParser.nonterminal_token, "foo", /* NonterminalName */Block.__(1, ["foo"]));
        expectParse(ConcreteSyntaxParser.nonterminal_token, "BAR", /* TerminalName */Block.__(0, ["BAR"]));
        expectParse(ConcreteSyntaxParser.operator_match__test, "foo BAR baz { foo($1; $2) }", /* OperatorMatch */[/* record */[
                /* tokens : :: */[
                  /* NonterminalName */Block.__(1, ["foo"]),
                  /* :: */[
                    /* TerminalName */Block.__(0, ["BAR"]),
                    /* :: */[
                      /* NonterminalName */Block.__(1, ["baz"]),
                      /* [] */0
                    ]
                  ]
                ],
                /* term_pattern : TermPattern */Block.__(0, [
                    "foo",
                    /* :: */[
                      /* NumberedScopePattern */[
                        /* [] */0,
                        1
                      ],
                      /* :: */[
                        /* NumberedScopePattern */[
                          /* [] */0,
                          2
                        ],
                        /* [] */0
                      ]
                    ]
                  ]),
                /* fixity : Nofix */2
              ]]);
        return expectParse(ConcreteSyntaxParser.sort_rule__test, "\n       arith :=\n         | arith ADD arith { add($1; $3) } %left\n         | arith SUB arith { sub($1; $3) } %left\n         > NAME            { var($1)     }\n    ", /* SortRule */[/* record */[
                      /* sort_name */"arith",
                      /* operator_rules : :: */[
                        /* :: */[
                          /* OperatorMatch */[/* record */[
                              /* tokens : :: */[
                                /* NonterminalName */Block.__(1, ["arith"]),
                                /* :: */[
                                  /* TerminalName */Block.__(0, ["ADD"]),
                                  /* :: */[
                                    /* NonterminalName */Block.__(1, ["arith"]),
                                    /* [] */0
                                  ]
                                ]
                              ],
                              /* term_pattern : TermPattern */Block.__(0, [
                                  "add",
                                  /* :: */[
                                    /* NumberedScopePattern */[
                                      /* [] */0,
                                      1
                                    ],
                                    /* :: */[
                                      /* NumberedScopePattern */[
                                        /* [] */0,
                                        3
                                      ],
                                      /* [] */0
                                    ]
                                  ]
                                ]),
                              /* fixity : Infixl */0
                            ]],
                          /* :: */[
                            /* OperatorMatch */[/* record */[
                                /* tokens : :: */[
                                  /* NonterminalName */Block.__(1, ["arith"]),
                                  /* :: */[
                                    /* TerminalName */Block.__(0, ["SUB"]),
                                    /* :: */[
                                      /* NonterminalName */Block.__(1, ["arith"]),
                                      /* [] */0
                                    ]
                                  ]
                                ],
                                /* term_pattern : TermPattern */Block.__(0, [
                                    "sub",
                                    /* :: */[
                                      /* NumberedScopePattern */[
                                        /* [] */0,
                                        1
                                      ],
                                      /* :: */[
                                        /* NumberedScopePattern */[
                                          /* [] */0,
                                          3
                                        ],
                                        /* [] */0
                                      ]
                                    ]
                                  ]),
                                /* fixity : Infixl */0
                              ]],
                            /* [] */0
                          ]
                        ],
                        /* [] */0
                      ],
                      /* variable *//* record */[
                        /* tokens : :: */[
                          /* TerminalName */Block.__(0, ["NAME"]),
                          /* [] */0
                        ],
                        /* var_capture */1
                      ]
                    ]]);
      }));

/*  Not a pure module */
