// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var Char = require("bs-platform/lib/js/char.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function take(n, xs) {
  if (n !== 0 && xs) {
    var xs$1 = xs[1];
    var xs$prime = take(n - 1 | 0, xs$1);
    if (xs$1 === xs$prime) {
      return xs;
    } else {
      return /* :: */[
              xs[0],
              xs$prime
            ];
    }
  } else {
    return /* [] */0;
  }
}

function drop(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n !== 0) {
      if (xs) {
        _xs = xs[1];
        _n = n - 1 | 0;
        continue ;
      } else {
        return /* [] */0;
      }
    } else {
      return xs;
    }
  };
}

function uniq1(_cmp, x, _ys) {
  while(true) {
    var ys = _ys;
    var cmp = _cmp;
    if (ys) {
      var ys$1 = ys[1];
      var y = ys[0];
      if (Curry._2(cmp, x, y) === 0) {
        _ys = ys$1;
        _cmp = Caml_obj.caml_compare;
        continue ;
      } else {
        return /* :: */[
                y,
                uniq1(cmp, y, ys$1)
              ];
      }
    } else {
      return /* [] */0;
    }
  };
}

function uniq(cmp, xs) {
  if (xs) {
    var x = xs[0];
    return /* :: */[
            x,
            uniq1(cmp, x, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function weed(cmp, xs) {
  return uniq(cmp, List.sort(cmp, xs));
}

function length(xs) {
  var tag = xs.tag | 0;
  var match = tag === 250 ? xs[0] : (
      tag === 246 ? CamlinternalLazy.force_lazy_block(xs) : xs
    );
  if (match) {
    return 1 + length(match[1]) | 0;
  } else {
    return 0;
  }
}

function foldr(f, xs, accu) {
  var tag = xs.tag | 0;
  var match = tag === 250 ? xs[0] : (
      tag === 246 ? CamlinternalLazy.force_lazy_block(xs) : xs
    );
  if (match) {
    return Curry._2(f, match[0], foldr(f, match[1], accu));
  } else {
    return accu;
  }
}

var General = /* module */[
  /* take */take,
  /* drop */drop,
  /* uniq1 */uniq1,
  /* uniq */uniq,
  /* weed */weed,
  /* length */length,
  /* foldr */foldr
];

function traditional2revised(get_raw_token, get_startp, get_endp, parser, lexer) {
  var lexbuf = Lexing.from_string("");
  var lexer$1 = function (lexbuf) {
    var token = Curry._1(lexer, /* () */0);
    lexbuf[/* lex_start_p */10] = Curry._1(get_startp, token);
    lexbuf[/* lex_curr_p */11] = Curry._1(get_endp, token);
    return Curry._1(get_raw_token, token);
  };
  return Curry._2(parser, lexer$1, lexbuf);
}

function revised2traditional(make_token, parser, lexer, lexbuf) {
  return Curry._1(parser, (function (param) {
                var token = Curry._1(lexer, lexbuf);
                return Curry._3(make_token, token, lexbuf[/* lex_start_p */10], lexbuf[/* lex_curr_p */11]);
              }));
}

function traditional2revised$1(parser) {
  return (function (param) {
      return traditional2revised((function (param) {
                    return param[0];
                  }), (function (param) {
                    return param[1];
                  }), (function (param) {
                    return param[2];
                  }), parser, param);
    });
}

function revised2traditional$1(parser) {
  return (function (param, param$1) {
      return revised2traditional((function (token, startp, endp) {
                    return /* tuple */[
                            token,
                            startp,
                            endp
                          ];
                  }), parser, param, param$1);
    });
}

var Simplified = /* module */[
  /* traditional2revised */traditional2revised$1,
  /* revised2traditional */revised2traditional$1
];

var Convert = /* module */[
  /* traditional2revised */traditional2revised,
  /* revised2traditional */revised2traditional,
  /* Simplified */Simplified
];

var IncrementalEngine = /* module */[];

var EngineTypes = /* module */[];

function Make(T) {
  var number = T[0];
  var $$Error = T[14];
  var log = T[17];
  var Log = T[18];
  var run = function (env, please_discard) {
    if (log) {
      Curry._1(Log[/* state */0], env[/* current */3]);
    }
    if (please_discard) {
      return /* InputNeeded */Block.__(0, [env]);
    } else {
      return check_for_default_reduction(env);
    }
  };
  var reduce = function (env, prod) {
    if (log) {
      Curry._1(Log[/* reduce_or_accept */2], prod);
    }
    var exit = 0;
    var stack;
    try {
      stack = Curry._2(T[/* semantic_action */15], prod, env);
      exit = 1;
    }
    catch (exn){
      if (exn === $$Error) {
        return initiate(env);
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      var current = Curry._2(T[/* goto_prod */11], stack[/* state */0], prod);
      var env_000 = /* error */env[/* error */0];
      var env_001 = /* triple */env[/* triple */1];
      var env$1 = /* record */[
        env_000,
        env_001,
        /* stack */stack,
        /* current */current
      ];
      return run(env$1, false);
    }
    
  };
  var check_for_error_token = function (env) {
    if (env[/* error */0]) {
      if (log) {
        Curry._1(Log[/* resuming_error_handling */5], /* () */0);
      }
      return /* HandlingError */Block.__(3, [env]);
    } else {
      var match = env[/* triple */1];
      var token = match[0];
      return Curry._7(T[/* action */9], env[/* current */3], Curry._1(T[/* token2terminal */1], token), Curry._1(T[/* token2value */2], token), shift, announce_reduce, initiate, env);
    }
  };
  var announce_reduce = function (env, prod) {
    if (Curry._1(T[/* is_start */13], prod)) {
      return accept(env, prod);
    } else {
      return /* AboutToReduce */Block.__(2, [
                env,
                prod
              ]);
    }
  };
  var shift = function (env, please_discard, terminal, value, s$prime) {
    if (log) {
      Curry._2(Log[/* shift */1], terminal, s$prime);
    }
    var match = env[/* triple */1];
    var stack_000 = /* state */env[/* current */3];
    var stack_002 = /* startp */match[1];
    var stack_003 = /* endp */match[2];
    var stack_004 = /* next */env[/* stack */2];
    var stack = /* record */[
      stack_000,
      /* semv */value,
      stack_002,
      stack_003,
      stack_004
    ];
    var new_env_000 = /* error */env[/* error */0];
    var new_env_001 = /* triple */env[/* triple */1];
    var new_env = /* record */[
      new_env_000,
      new_env_001,
      /* stack */stack,
      /* current */s$prime
    ];
    return /* Shifting */Block.__(1, [
              env,
              new_env,
              please_discard
            ]);
  };
  var initiate = function (env) {
    if (log) {
      Curry._1(Log[/* initiating_error_handling */4], /* () */0);
    }
    var env_001 = /* triple */env[/* triple */1];
    var env_002 = /* stack */env[/* stack */2];
    var env_003 = /* current */env[/* current */3];
    var env$1 = /* record */[
      /* error */true,
      env_001,
      env_002,
      env_003
    ];
    return /* HandlingError */Block.__(3, [env$1]);
  };
  var accept = function (env, prod) {
    if (log) {
      Curry._1(Log[/* reduce_or_accept */2], prod);
    }
    var v = env[/* stack */2][/* semv */1];
    return /* Accepted */Block.__(4, [v]);
  };
  var check_for_default_reduction = function (env) {
    return Curry._4(T[/* default_reduction */8], env[/* current */3], announce_reduce, check_for_error_token, env);
  };
  var error_fail = function (env) {
    var cell = env[/* stack */2];
    var next = cell[/* next */4];
    if (next === cell) {
      return /* Rejected */0;
    } else {
      var env_000 = /* error */env[/* error */0];
      var env_001 = /* triple */env[/* triple */1];
      var env_003 = /* current */cell[/* state */0];
      var env$1 = /* record */[
        env_000,
        env_001,
        /* stack */next,
        env_003
      ];
      return /* HandlingError */Block.__(3, [env$1]);
    }
  };
  var error_shift = function (env, please_discard, terminal, value, s$prime) {
    if (!(Caml_obj.caml_equal(terminal, T[/* error_terminal */3]) && Caml_obj.caml_equal(value, T[/* error_value */4]))) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              1399,
              4
            ]
          ];
    }
    if (log) {
      Curry._1(Log[/* handling_error */6], env[/* current */3]);
    }
    return shift(env, please_discard, terminal, value, s$prime);
  };
  var error_reduce = function (env, prod) {
    if (log) {
      Curry._1(Log[/* handling_error */6], env[/* current */3]);
    }
    return reduce(env, prod);
  };
  var discard = function (env, triple) {
    if (log) {
      Curry._3(Log[/* lookahead_token */3], Curry._1(T[/* token2terminal */1], triple[0]), triple[1], triple[2]);
    }
    return check_for_default_reduction(/* record */[
                /* error */false,
                /* triple */triple,
                /* stack */env[/* stack */2],
                /* current */env[/* current */3]
              ]);
  };
  var error = function (env) {
    if (!env[/* error */0]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              1380,
              4
            ]
          ];
    }
    return Curry._7(T[/* action */9], env[/* current */3], T[/* error_terminal */3], T[/* error_value */4], error_shift, error_reduce, error_fail, env);
  };
  var start = function (s, initial) {
    var empty = [];
    Caml_obj.caml_update_dummy(empty, /* record */[
          /* state */s,
          /* semv */T[/* error_value */4],
          /* startp */initial,
          /* endp */initial,
          /* next */empty
        ]);
    var env_001 = /* triple : tuple */[
      /* () */0,
      initial,
      initial
    ];
    var env = /* record */[
      /* error */false,
      env_001,
      /* stack */empty,
      /* current */s
    ];
    return run(env, true);
  };
  var offer = function (param) {
    if (typeof param === "number" || param.tag) {
      return Pervasives.invalid_arg("offer expects InputNeeded");
    } else {
      var partial_arg = param[0];
      return (function (param) {
          return discard(partial_arg, param);
        });
    }
  };
  var resume = function (param) {
    if (typeof param === "number") {
      return Pervasives.invalid_arg("resume expects HandlingError | Shifting | AboutToReduce");
    } else {
      switch (param.tag | 0) {
        case 1 : 
            return run(param[1], param[2]);
        case 2 : 
            return reduce(param[0], param[1]);
        case 3 : 
            return error(param[0]);
        default:
          return Pervasives.invalid_arg("resume expects HandlingError | Shifting | AboutToReduce");
      }
    }
  };
  var lexer_lexbuf_to_supplier = function (lexer, lexbuf, param) {
    var token = Curry._1(lexer, lexbuf);
    var startp = lexbuf[/* lex_start_p */10];
    var endp = lexbuf[/* lex_curr_p */11];
    return /* tuple */[
            token,
            startp,
            endp
          ];
  };
  var loop = function (read, _checkpoint) {
    while(true) {
      var checkpoint = _checkpoint;
      if (typeof checkpoint === "number") {
        throw $$Error;
      } else {
        switch (checkpoint.tag | 0) {
          case 0 : 
              var triple = Curry._1(read, /* () */0);
              var checkpoint$1 = offer(checkpoint)(triple);
              _checkpoint = checkpoint$1;
              continue ;
          case 4 : 
              return checkpoint[0];
          default:
            var checkpoint$2 = resume(checkpoint);
            _checkpoint = checkpoint$2;
            continue ;
        }
      }
    };
  };
  var entry = function (s, lexer, lexbuf) {
    var initial = lexbuf[/* lex_curr_p */11];
    return loop((function (param) {
                  return lexer_lexbuf_to_supplier(lexer, lexbuf, param);
                }), start(s, initial));
  };
  var loop_handle = function (succeed, fail, read, _checkpoint) {
    while(true) {
      var checkpoint = _checkpoint;
      var exit = 0;
      if (typeof checkpoint === "number") {
        return Curry._1(fail, checkpoint);
      } else {
        switch (checkpoint.tag | 0) {
          case 0 : 
              var triple = Curry._1(read, /* () */0);
              var checkpoint$1 = offer(checkpoint)(triple);
              _checkpoint = checkpoint$1;
              continue ;
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          case 3 : 
              return Curry._1(fail, checkpoint);
          case 4 : 
              return Curry._1(succeed, checkpoint[0]);
          
        }
      }
      if (exit === 1) {
        var checkpoint$2 = resume(checkpoint);
        _checkpoint = checkpoint$2;
        continue ;
      }
      
    };
  };
  var loop_handle_undo = function (succeed, fail, read, checkpoint) {
    var tmp;
    tmp = typeof checkpoint === "number" || checkpoint.tag ? false : true;
    if (!tmp) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              1672,
              4
            ]
          ];
    }
    var succeed$1 = succeed;
    var fail$1 = fail;
    var read$1 = read;
    var _param = /* tuple */[
      checkpoint,
      checkpoint
    ];
    while(true) {
      var param = _param;
      var checkpoint$1 = param[1];
      var inputneeded = param[0];
      var exit = 0;
      if (typeof checkpoint$1 === "number") {
        return Curry._2(fail$1, inputneeded, checkpoint$1);
      } else {
        switch (checkpoint$1.tag | 0) {
          case 0 : 
              var triple = Curry._1(read$1, /* () */0);
              var checkpoint$2 = offer(checkpoint$1)(triple);
              _param = /* tuple */[
                checkpoint$1,
                checkpoint$2
              ];
              continue ;
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          case 3 : 
              return Curry._2(fail$1, inputneeded, checkpoint$1);
          case 4 : 
              return Curry._1(succeed$1, checkpoint$1[0]);
          
        }
      }
      if (exit === 1) {
        var checkpoint$3 = resume(checkpoint$1);
        _param = /* tuple */[
          inputneeded,
          checkpoint$3
        ];
        continue ;
      }
      
    };
  };
  var shifts = function (_checkpoint) {
    while(true) {
      var checkpoint = _checkpoint;
      if (typeof checkpoint === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "menhirLib.ml",
                1697,
                8
              ]
            ];
      } else {
        switch (checkpoint.tag | 0) {
          case 1 : 
              return checkpoint[0];
          case 2 : 
              _checkpoint = resume(checkpoint);
              continue ;
          case 3 : 
              return undefined;
          default:
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "menhirLib.ml",
                    1697,
                    8
                  ]
                ];
        }
      }
    };
  };
  var acceptable = function (checkpoint, token, pos) {
    var triple = /* tuple */[
      token,
      pos,
      pos
    ];
    var checkpoint$1 = offer(checkpoint)(triple);
    return shifts(checkpoint$1) !== undefined;
  };
  var stack = function (cell, current) {
    return Block.__(246, [(function (param) {
                  var next = cell[/* next */4];
                  if (next === cell) {
                    return /* Nil */0;
                  } else {
                    var element_001 = cell[/* semv */1];
                    var element_002 = cell[/* startp */2];
                    var element_003 = cell[/* endp */3];
                    var element = /* Element */[
                      current,
                      element_001,
                      element_002,
                      element_003
                    ];
                    return /* Cons */[
                            element,
                            stack(next, cell[/* state */0])
                          ];
                  }
                })]);
  };
  var stack$1 = function (env) {
    return stack(env[/* stack */2], env[/* current */3]);
  };
  var top = function (env) {
    var cell = env[/* stack */2];
    var next = cell[/* next */4];
    if (next === cell) {
      return undefined;
    } else {
      return /* Element */[
              env[/* current */3],
              cell[/* semv */1],
              cell[/* startp */2],
              cell[/* endp */3]
            ];
    }
  };
  var equal = function (env1, env2) {
    if (env1[/* stack */2] === env2[/* stack */2]) {
      return Curry._1(number, env1[/* current */3]) === Curry._1(number, env2[/* current */3]);
    } else {
      return false;
    }
  };
  var current_state_number = function (env) {
    return Curry._1(number, env[/* current */3]);
  };
  var positions = function (param) {
    var match = param[/* triple */1];
    return /* tuple */[
            match[1],
            match[2]
          ];
  };
  var state_has_default_reduction = function (state) {
    return Curry._4(T[/* default_reduction */8], state, (function (_env, _prod) {
                  return true;
                }), (function (_env) {
                  return false;
                }), /* () */0);
  };
  var env_has_default_reduction = function (env) {
    return state_has_default_reduction(env[/* current */3]);
  };
  var pop = function (env) {
    var cell = env[/* stack */2];
    var next = cell[/* next */4];
    if (next === cell) {
      return undefined;
    } else {
      return /* record */[
              /* error */env[/* error */0],
              /* triple */env[/* triple */1],
              /* stack */next,
              /* current */cell[/* state */0]
            ];
    }
  };
  var force_reduction = function (prod, env) {
    if (Curry._2(T[/* may_reduce */16], env[/* current */3], prod)) {
      if (Curry._1(T[/* is_start */13], prod)) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "menhirLib.ml",
                1885,
                6
              ]
            ];
      }
      var stack = Curry._2(T[/* semantic_action */15], prod, env);
      var current = Curry._2(T[/* goto_prod */11], stack[/* state */0], prod);
      return /* record */[
              /* error */env[/* error */0],
              /* triple */env[/* triple */1],
              /* stack */stack,
              /* current */current
            ];
    } else {
      return Pervasives.invalid_arg("force_reduction: this reduction is not permitted in this state");
    }
  };
  var input_needed = function (env) {
    return /* InputNeeded */Block.__(0, [env]);
  };
  var pop_many = function (_i, _env) {
    while(true) {
      var env = _env;
      var i = _i;
      if (i === 0) {
        return env;
      } else {
        var match = pop(env);
        if (match !== undefined) {
          _env = match;
          _i = i - 1 | 0;
          continue ;
        } else {
          return undefined;
        }
      }
    };
  };
  var get = function (i, env) {
    var match = pop_many(i, env);
    if (match !== undefined) {
      return top(match);
    }
    
  };
  return /* module */[
          /* number */number,
          /* token2terminal */T[1],
          /* token2value */T[2],
          /* error_terminal */T[3],
          /* error_value */T[4],
          /* foreach_terminal */T[5],
          /* production_index */T[6],
          /* find_production */T[7],
          /* default_reduction */T[8],
          /* action */T[9],
          /* goto_nt */T[10],
          /* goto_prod */T[11],
          /* maybe_goto_nt */T[12],
          /* is_start */T[13],
          /* Error */$$Error,
          /* semantic_action */T[15],
          /* may_reduce */T[16],
          /* log */log,
          /* Log */Log,
          /* run */run,
          /* discard */discard,
          /* check_for_default_reduction */check_for_default_reduction,
          /* check_for_error_token */check_for_error_token,
          /* shift */shift,
          /* announce_reduce */announce_reduce,
          /* reduce */reduce,
          /* accept */accept,
          /* initiate */initiate,
          /* error */error,
          /* error_shift */error_shift,
          /* error_reduce */error_reduce,
          /* error_fail */error_fail,
          /* start */start,
          /* offer */offer,
          /* resume */resume,
          /* lexer_lexbuf_to_supplier */lexer_lexbuf_to_supplier,
          /* loop */loop,
          /* entry */entry,
          /* loop_handle */loop_handle,
          /* loop_handle_undo */loop_handle_undo,
          /* shifts */shifts,
          /* acceptable */acceptable,
          /* stack */stack$1,
          /* top */top,
          /* equal */equal,
          /* current_state_number */current_state_number,
          /* positions */positions,
          /* state_has_default_reduction */state_has_default_reduction,
          /* env_has_default_reduction */env_has_default_reduction,
          /* pop */pop,
          /* force_reduction */force_reduction,
          /* input_needed */input_needed,
          /* pop_many */pop_many,
          /* get */get
        ];
}

var Engine = /* module */[/* Make */Make];

function update(buffer, x) {
  var match = buffer[0];
  var tmp;
  tmp = typeof match === "number" ? /* One */Block.__(0, [x]) : (
      match.tag ? /* Two */Block.__(1, [
            match[1],
            x
          ]) : /* Two */Block.__(1, [
            match[0],
            x
          ])
    );
  buffer[0] = tmp;
  return /* () */0;
}

function show(f, buffer) {
  var match = buffer[0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            1978,
            6
          ]
        ];
  } else if (match.tag) {
    return Curry._2(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "after '",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                "' and before '",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* "'" */39,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "after '%s' and before '%s'"
                  ]), Curry._1(f, match[0]), Curry._1(f, match[1]));
  } else {
    return Curry._1(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "before '",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* Char_literal */Block.__(12, [
                                /* "'" */39,
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    "before '%s'"
                  ]), Curry._1(f, match[0]));
  }
}

function last(buffer) {
  var match = buffer[0];
  if (typeof match === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            1994,
            6
          ]
        ];
  } else if (match.tag) {
    return match[1];
  } else {
    return match[0];
  }
}

function wrap(lexer) {
  var buffer = /* record */[/* contents : Zero */0];
  return /* tuple */[
          buffer,
          (function (lexbuf) {
              var token = Curry._1(lexer, lexbuf);
              update(buffer, /* tuple */[
                    lexbuf[/* lex_start_p */10],
                    lexbuf[/* lex_curr_p */11]
                  ]);
              return token;
            })
        ];
}

var ErrorReports = /* module */[
  /* update */update,
  /* show */show,
  /* last */last,
  /* wrap */wrap
];

function Make$1(I) {
  return (function (User) {
      var arrow = " -> ";
      var dot = ".";
      var space = " ";
      var newline = "\n";
      var print_symbols = function (_i, _symbols) {
        while(true) {
          var symbols = _symbols;
          var i = _i;
          if (i === 0) {
            Curry._1(User[/* print */0], dot);
            Curry._1(User[/* print */0], space);
            _i = -1;
            continue ;
          } else if (symbols) {
            Curry._1(User[/* print_symbol */1], symbols[0]);
            Curry._1(User[/* print */0], space);
            _symbols = symbols[1];
            _i = i - 1 | 0;
            continue ;
          } else {
            return /* () */0;
          }
        };
      };
      var print_element_as_symbol = function (element) {
        return Curry._1(User[/* print_symbol */1], /* X */[Curry._1(I[/* incoming_symbol */28], element[0])]);
      };
      var match = User[/* print_element */2];
      var print_element = match !== undefined ? match : print_element_as_symbol;
      var print_stack = function (env) {
        var match = Curry._1(I[/* top */12], env);
        var match$1 = Curry._1(I[/* pop */20], env);
        if (match !== undefined && match$1 !== undefined) {
          print_stack(Caml_option.valFromOption(match$1));
          Curry._1(User[/* print */0], space);
          return Curry._1(print_element, match);
        } else {
          return /* () */0;
        }
      };
      var print_stack$1 = function (env) {
        print_stack(env);
        return Curry._1(User[/* print */0], newline);
      };
      var print_item = function (param) {
        var prod = param[0];
        Curry._1(User[/* print_symbol */1], Curry._1(I[/* lhs */30], prod));
        Curry._1(User[/* print */0], arrow);
        print_symbols(param[1], Curry._1(I[/* rhs */31], prod));
        return Curry._1(User[/* print */0], newline);
      };
      var print_symbols$1 = function (symbols) {
        return print_symbols(-1, symbols);
      };
      var print_production = function (prod) {
        return print_item(/* tuple */[
                    prod,
                    -1
                  ]);
      };
      var print_current_state = function (env) {
        Curry._1(User[/* print */0], "Current LR(1) state: ");
        var match = Curry._1(I[/* top */12], env);
        if (match !== undefined) {
          var current = match[0];
          Curry._1(User[/* print */0], String(Curry._1(I[/* number */8], current)));
          Curry._1(User[/* print */0], newline);
          return List.iter(print_item, Curry._1(I[/* items */29], current));
        } else {
          Curry._1(User[/* print */0], "<some initial state>");
          return Curry._1(User[/* print */0], newline);
        }
      };
      var print_env = function (env) {
        print_stack$1(env);
        print_current_state(env);
        return Curry._1(User[/* print */0], newline);
      };
      return /* module */[
              /* arrow */arrow,
              /* dot */dot,
              /* space */space,
              /* newline */newline,
              /* print_element_as_symbol */print_element_as_symbol,
              /* print_element */print_element,
              /* print_stack */print_stack$1,
              /* print_item */print_item,
              /* print_symbols */print_symbols$1,
              /* print_production */print_production,
              /* print_current_state */print_current_state,
              /* print_env */print_env
            ];
    });
}

var Printers = /* module */[/* Make */Make$1];

function make(x) {
  return /* record */[
          /* default */x,
          /* table */Caml_array.caml_make_vect(16384, x),
          /* extent */0
        ];
}

function new_length(_length, i) {
  while(true) {
    var length = _length;
    if (i < length) {
      return length;
    } else {
      _length = (length << 1);
      continue ;
    }
  };
}

function ensure(a, i) {
  if (0 > i) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2175,
            2
          ]
        ];
  }
  var table = a[/* table */1];
  var length = table.length;
  if (i >= length) {
    var table$prime = Caml_array.caml_make_vect(new_length((length << 1), i), a[/* default */0]);
    $$Array.blit(table, 0, table$prime, 0, length);
    a[/* table */1] = table$prime;
    return /* () */0;
  } else {
    return 0;
  }
}

function get(a, i) {
  ensure(a, i);
  return a[/* table */1][i];
}

function set(a, i, x) {
  ensure(a, i);
  a[/* table */1][i] = x;
  if (a[/* extent */2] <= i) {
    a[/* extent */2] = i + 1 | 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function extent(a) {
  return a[/* extent */2];
}

function domain(a) {
  return $$Array.sub(a[/* table */1], 0, a[/* extent */2]);
}

var InfiniteArray = /* module */[
  /* default_size */16384,
  /* make */make,
  /* new_length */new_length,
  /* ensure */ensure,
  /* get */get,
  /* set */set,
  /* extent */extent,
  /* domain */domain
];

function magnitude(v) {
  if (v < 0) {
    return Sys.word_size;
  } else {
    var _k = 1;
    var _max = 2;
    while(true) {
      var max = _max;
      var k = _k;
      if (max <= 0 || v < max) {
        return k;
      } else {
        _max = Caml_int32.imul(max, max);
        _k = (k << 1);
        continue ;
      }
    };
  }
}

function pack(a) {
  var m = a.length;
  var k = $$Array.fold_left((function (k, v) {
          return Caml_primitive.caml_int_max(k, magnitude(v));
        }), 1, a);
  if (k <= 8) {
    if (Caml_int32.mod_(8, k) !== 0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              2278,
              4
            ]
          ];
    }
    var w = Caml_int32.div(8, k);
    var n = Caml_int32.mod_(m, w) === 0 ? Caml_int32.div(m, w) : Caml_int32.div(m, w) + 1 | 0;
    var s = Caml_bytes.caml_create_bytes(n);
    var i = /* record */[/* contents */0];
    var next = function (param) {
      var ii = i[0];
      if (ii === m) {
        return 0;
      } else {
        var v = Caml_array.caml_array_get(a, ii);
        i[0] = ii + 1 | 0;
        return v;
      }
    };
    for(var j = 0 ,j_finish = n - 1 | 0; j <= j_finish; ++j){
      var c = 0;
      for(var _x = 1; _x <= w; ++_x){
        c = (c << k) | next(/* () */0);
      }
      s[j] = Char.chr(c);
    }
    return /* tuple */[
            k,
            Bytes.unsafe_to_string(s)
          ];
  } else {
    if (k % 8 !== 0) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              2327,
              4
            ]
          ];
    }
    var w$1 = k / 8 | 0;
    var n$1 = Caml_int32.imul(m, w$1);
    var s$1 = Caml_bytes.caml_create_bytes(n$1);
    for(var i$1 = 0 ,i_finish = m - 1 | 0; i$1 <= i_finish; ++i$1){
      var v = Caml_array.caml_array_get(a, i$1);
      for(var x = 1; x <= w$1; ++x){
        s$1[Caml_int32.imul(i$1 + 1 | 0, w$1) - x | 0] = Char.chr(v & 255);
        v = (v >>> 8);
      }
    }
    return /* tuple */[
            k,
            Bytes.unsafe_to_string(s$1)
          ];
  }
}

function read(s, i) {
  return s.charCodeAt(i);
}

function get1(s, i) {
  var c = s.charCodeAt((i >>> 3));
  var c$1 = (c >>> (Pervasives.lnot(i) & 7)) | 0;
  return c$1 & 1;
}

function get$1(param, i) {
  var s = param[1];
  var k = param[0];
  var exit = 0;
  switch (k) {
    case 1 : 
        return get1(s, i);
    case 2 : 
        var c = s.charCodeAt((i >>> 2));
        var c$1 = (c >>> ((Pervasives.lnot(i) & 3) << 1)) | 0;
        return c$1 & 3;
    case 4 : 
        var c$2 = s.charCodeAt((i >>> 1));
        var c$3 = (c$2 >>> ((Pervasives.lnot(i) & 1) << 2)) | 0;
        return c$3 & 15;
    case 8 : 
        return s.charCodeAt(i);
    case 3 : 
    case 5 : 
    case 6 : 
    case 7 : 
    case 9 : 
    case 10 : 
    case 11 : 
    case 12 : 
    case 13 : 
    case 14 : 
    case 15 : 
        exit = 1;
        break;
    case 16 : 
        var j = (i << 1);
        return (s.charCodeAt(j) << 8) + s.charCodeAt(j + 1 | 0) | 0;
    default:
      exit = 1;
  }
  if (exit === 1) {
    if (k !== 32) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              2396,
              6
            ]
          ];
    }
    var j$1 = (i << 2);
    return (((((s.charCodeAt(j$1) << 8) + s.charCodeAt(j$1 + 1 | 0) | 0) << 8) + s.charCodeAt(j$1 + 2 | 0) | 0) << 8) + s.charCodeAt(j$1 + 3 | 0) | 0;
  }
  
}

function unflatten1(param, i, j) {
  return get1(param[1], Caml_int32.imul(param[0], i) + j | 0);
}

var PackedIntArray = /* module */[
  /* magnitude */magnitude,
  /* pack */pack,
  /* read */read,
  /* get1 */get1,
  /* get */get$1,
  /* unflatten1 */unflatten1
];

function encode(displacement) {
  if (displacement >= 0) {
    return (displacement << 1);
  } else {
    return ((-displacement | 0) << 1) + 1 | 0;
  }
}

function decode(displacement) {
  if ((displacement & 1) === 0) {
    return (displacement >>> 1);
  } else {
    return -(displacement >>> 1) | 0;
  }
}

function compress(equal, insignificant, dummy, m, n, t) {
  if (t.length !== m) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2492,
            2
          ]
        ];
  }
  for(var i = 0 ,i_finish = m - 1 | 0; i <= i_finish; ++i){
    if (Caml_array.caml_array_get(t, i).length !== n) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              2495,
              6
            ]
          ];
    }
    
  }
  var sparse = function (i, line) {
    var _j = n - 1 | 0;
    var _rank = 0;
    var _row = /* [] */0;
    while(true) {
      var row = _row;
      var rank = _rank;
      var j = _j;
      if (j < 0) {
        return /* tuple */[
                i,
                rank,
                row
              ];
      } else {
        var x = Caml_array.caml_array_get(line, j);
        if (Curry._1(insignificant, x)) {
          _j = j - 1 | 0;
          continue ;
        } else {
          _row = /* :: */[
            /* tuple */[
              j,
              x
            ],
            row
          ];
          _rank = 1 + rank | 0;
          _j = j - 1 | 0;
          continue ;
        }
      }
    };
  };
  var rows = $$Array.mapi(sparse, t);
  $$Array.fast_sort((function (param, param$1) {
          return Caml_primitive.caml_int_compare(param$1[1], param[1]);
        }), rows);
  var displacement = Caml_array.caml_make_vect(m, 0);
  var data = make(dummy);
  var fits = function (k, row) {
    var d = data[/* extent */2];
    var _param = row;
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        var j = match[0];
        if ((k + j | 0) < 0) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "menhirLib.ml",
                  2573,
                  10
                ]
              ];
        }
        if ((k + j | 0) >= d) {
          return true;
        } else {
          var y = get(data, k + j | 0);
          if (Curry._1(insignificant, y) || Curry._2(equal, match[1], y)) {
            _param = param[1];
            continue ;
          } else {
            return false;
          }
        }
      } else {
        return true;
      }
    };
  };
  var fit = function (row) {
    if (row) {
      var _k = -row[0][0] | 0;
      var row$1 = row;
      while(true) {
        var k = _k;
        if (fits(k, row$1)) {
          return k;
        } else {
          _k = k + 1 | 0;
          continue ;
        }
      };
    } else {
      return 0;
    }
  };
  var write = function (k, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        set(data, k + match[0] | 0, match[1]);
        _param = param[1];
        continue ;
      } else {
        return /* () */0;
      }
    };
  };
  $$Array.iter((function (param) {
          var row = param[2];
          var k = fit(row);
          write(k, row);
          return Caml_array.caml_array_set(displacement, param[0], encode(k));
        }), rows);
  return /* tuple */[
          displacement,
          domain(data)
        ];
}

function get$2(param, i, j) {
  var data = param[1];
  var displacement = param[0];
  if (!(0 <= i && i < displacement.length)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2655,
            2
          ]
        ];
  }
  var k = decode(Caml_array.caml_array_get(displacement, i));
  if (!(0 <= (k + j | 0) && (k + j | 0) < data.length)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2657,
            2
          ]
        ];
  }
  return Caml_array.caml_array_get(data, k + j | 0);
}

function getget(get_displacement, get_data, param, i, j) {
  var k = decode(Curry._2(get_displacement, param[0], i));
  return Curry._2(get_data, param[1], k + j | 0);
}

var RowDisplacement = /* module */[
  /* encode */encode,
  /* decode */decode,
  /* compress */compress,
  /* get */get$2,
  /* getget */getget
];

function make$1(a) {
  var n = a.length;
  var size = /* record */[/* contents */0];
  var entry = $$Array.init(n + 1 | 0, (function (i) {
          var s = size[0];
          if (i < n) {
            size[0] = s + Caml_array.caml_array_get(a, i).length | 0;
          }
          return s;
        }));
  if (Caml_array.caml_array_get(entry, n) !== size[0]) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2703,
            2
          ]
        ];
  }
  var i = /* record */[/* contents */0];
  var j = /* record */[/* contents */0];
  var data = $$Array.init(size[0], (function (param) {
          while(j[0] === Caml_array.caml_array_get(a, i[0]).length) {
            i[0] = i[0] + 1 | 0;
            j[0] = 0;
          };
          var x = Caml_array.caml_array_get(Caml_array.caml_array_get(a, i[0]), j[0]);
          j[0] = j[0] + 1 | 0;
          return x;
        }));
  return /* tuple */[
          data,
          entry
        ];
}

function length$1(param) {
  return param[1].length;
}

function row_length(param, i) {
  var entry = param[1];
  return Caml_array.caml_array_get(entry, i + 1 | 0) - Caml_array.caml_array_get(entry, i) | 0;
}

function row_length_via(get_entry, i) {
  return Curry._1(get_entry, i + 1 | 0) - Curry._1(get_entry, i) | 0;
}

function read$1(la, i, j) {
  if (!(0 <= j && j < row_length(la, i))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2728,
            2
          ]
        ];
  }
  return Caml_array.caml_array_get(la[0], Caml_array.caml_array_get(la[1], i) + j | 0);
}

function read_via(get_data, get_entry, i, j) {
  if (!(0 <= j && j < row_length_via(get_entry, i))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2732,
            2
          ]
        ];
  }
  return Curry._1(get_data, Curry._1(get_entry, i) + j | 0);
}

function write(la, i, j, v) {
  if (!(0 <= j && j < row_length(la, i))) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "menhirLib.ml",
            2736,
            2
          ]
        ];
  }
  return Caml_array.caml_array_set(la[0], Caml_array.caml_array_get(la[1], i) + j | 0, v);
}

function read_interval_via(get_data, i, j) {
  if (i === j) {
    return /* [] */0;
  } else {
    return /* :: */[
            Curry._1(get_data, i),
            read_interval_via(get_data, i + 1 | 0, j)
          ];
  }
}

function read_row_via(get_data, get_entry, i) {
  return read_interval_via(get_data, Curry._1(get_entry, i), Curry._1(get_entry, i + 1 | 0));
}

function read_row(param, i) {
  var entry = param[1];
  var data = param[0];
  return read_row_via((function (param) {
                return Caml_array.caml_array_get(data, param);
              }), (function (param) {
                return Caml_array.caml_array_get(entry, param);
              }), i);
}

var LinearizedArray = /* module */[
  /* make */make$1,
  /* length */length$1,
  /* row_length */row_length,
  /* row_length_via */row_length_via,
  /* read */read$1,
  /* read_via */read_via,
  /* write */write,
  /* read_interval_via */read_interval_via,
  /* read_row_via */read_row_via,
  /* read_row */read_row
];

var TableFormat = /* module */[];

var InspectionTableFormat = /* module */[];

function Symbols(T) {
  return /* module */[];
}

function Make$2(TT) {
  return (function (IT) {
      return (function (ET) {
          return (function (E) {
              var read_packed_linearized = function (param, i) {
                var entry = param[1];
                var data = param[0];
                return read_row_via((function (param) {
                              return get$1(data, param);
                            }), (function (param) {
                              return get$1(entry, param);
                            }), i);
              };
              var decode_symbol = function (symbol) {
                if (symbol <= 0) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "menhirLib.ml",
                          3046,
                          4
                        ]
                      ];
                }
                var kind = symbol & 1;
                var symbol$1 = (symbol >>> 1);
                if (kind === 0) {
                  return Curry._1(IT[/* terminal */0], symbol$1 - 1 | 0);
                } else {
                  return Curry._1(IT[/* nonterminal */1], symbol$1);
                }
              };
              var n2i = function (nt) {
                var answer = TT[/* start */8] + nt | 0;
                if (!Caml_obj.caml_equal(Curry._1(IT[/* nonterminal */1], answer), /* X */[/* N */Block.__(1, [nt])])) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "menhirLib.ml",
                          3065,
                          4
                        ]
                      ];
                }
                return answer;
              };
              var t2i = function (t) {
                if (!Caml_obj.caml_equal(Curry._1(IT[/* terminal */0], t), /* X */[/* T */Block.__(0, [t])])) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "menhirLib.ml",
                          3071,
                          4
                        ]
                      ];
                }
                return t;
              };
              var compare_terminals = function (t1, t2) {
                return t2i(t1) - t2i(t2) | 0;
              };
              var compare_nonterminals = function (nt1, nt2) {
                return n2i(nt1) - n2i(nt2) | 0;
              };
              var compare_symbols = function (symbol1, symbol2) {
                var match = symbol1[0];
                if (match.tag) {
                  var match$1 = symbol2[0];
                  if (match$1.tag) {
                    return compare_nonterminals(match[0], match$1[0]);
                  } else {
                    return 1;
                  }
                } else {
                  var match$2 = symbol2[0];
                  if (match$2.tag) {
                    return -1;
                  } else {
                    return compare_terminals(match[0], match$2[0]);
                  }
                }
              };
              var compare_productions = function (prod1, prod2) {
                return prod1 - prod2 | 0;
              };
              var compare_items = function (param, param$1) {
                var c = param[0] - param$1[0] | 0;
                if (c !== 0) {
                  return c;
                } else {
                  return param[1] - param$1[1] | 0;
                }
              };
              var incoming_symbol = function (s) {
                var core = get$1(IT[/* lr0_core */3], s);
                return decode_symbol(get$1(IT[/* lr0_incoming */5], core))[0];
              };
              var lhs = function (prod) {
                return Curry._1(IT[/* nonterminal */1], get$1(TT[/* lhs */6], prod));
              };
              var rhs = function (prod) {
                return List.map(decode_symbol, read_packed_linearized(IT[/* rhs */2], prod));
              };
              var $$export = function (t) {
                return /* tuple */[
                        (t >>> 7),
                        t % 128
                      ];
              };
              var items = function (s) {
                var core = get$1(IT[/* lr0_core */3], s);
                return List.map($$export, read_packed_linearized(IT[/* lr0_items */4], core));
              };
              var decode_bool = function (i) {
                if (!(i === 0 || i === 1)) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "menhirLib.ml",
                          3152,
                          4
                        ]
                      ];
                }
                return i === 1;
              };
              var nullable = function (nt) {
                return decode_bool(get1(IT[/* nullable */6], n2i(nt)));
              };
              var first = function (nt, t) {
                return decode_bool(unflatten1(IT[/* first */7], n2i(nt), t2i(t)));
              };
              var xfirst = function (symbol, t) {
                var match = symbol[0];
                if (match.tag) {
                  return first(match[0], t);
                } else {
                  return compare_terminals(t, match[0]) === 0;
                }
              };
              var foldij = function (_i, j, f, _accu) {
                while(true) {
                  var accu = _accu;
                  var i = _i;
                  if (i === j) {
                    return accu;
                  } else {
                    _accu = Curry._2(f, i, accu);
                    _i = i + 1 | 0;
                    continue ;
                  }
                };
              };
              var foreach_terminal = function (f, accu) {
                var match = TT[/* error */4];
                return foldij(0, match[0], (function (i, accu) {
                              return Curry._2(f, Curry._1(IT[/* terminal */0], i), accu);
                            }), accu);
              };
              var foreach_terminal_but_error = function (f, accu) {
                var match = TT[/* error */4];
                return foldij(0, match[0], (function (i, accu) {
                              if (i === TT[/* error_terminal */1]) {
                                return accu;
                              } else {
                                return Curry._2(f, Curry._1(IT[/* terminal */0], i), accu);
                              }
                            }), accu);
              };
              var feed_failure = function (param) {
                return Pervasives.invalid_arg("feed: outgoing transition does not exist");
              };
              var feed_nonterminal = function (nt, startp, semv, endp, env) {
                var source = env[/* current */3];
                var match = Curry._2(ET[/* maybe_goto_nt */12], source, nt);
                if (match !== undefined) {
                  var stack_004 = /* next */env[/* stack */2];
                  var stack = /* record */[
                    /* state */source,
                    /* semv */semv,
                    /* startp */startp,
                    /* endp */endp,
                    stack_004
                  ];
                  return /* record */[
                          /* error */env[/* error */0],
                          /* triple */env[/* triple */1],
                          /* stack */stack,
                          /* current */Caml_option.valFromOption(match)
                        ];
                } else {
                  return Pervasives.invalid_arg("feed: outgoing transition does not exist");
                }
              };
              var reduce = function (_env, _prod) {
                return Pervasives.invalid_arg("feed: outgoing transition does not exist");
              };
              var initiate = function (_env) {
                return Pervasives.invalid_arg("feed: outgoing transition does not exist");
              };
              var feed_terminal = function (terminal, startp, semv, endp, env) {
                var source = env[/* current */3];
                return Curry._7(ET[/* action */9], source, terminal, semv, (function (env, _please_discard, _terminal, semv, target) {
                              var stack_004 = /* next */env[/* stack */2];
                              var stack = /* record */[
                                /* state */source,
                                /* semv */semv,
                                /* startp */startp,
                                /* endp */endp,
                                stack_004
                              ];
                              return /* record */[
                                      /* error */env[/* error */0],
                                      /* triple */env[/* triple */1],
                                      /* stack */stack,
                                      /* current */target
                                    ];
                            }), reduce, initiate, env);
              };
              var feed = function (symbol, startp, semv, endp, env) {
                if (symbol.tag) {
                  return feed_nonterminal(n2i(symbol[0]), startp, semv, endp, env);
                } else {
                  return feed_terminal(t2i(symbol[0]), startp, semv, endp, env);
                }
              };
              return /* module */[
                      /* terminal */IT[0],
                      /* nonterminal */IT[1],
                      /* lr0_core */IT[3],
                      /* lr0_items */IT[4],
                      /* lr0_incoming */IT[5],
                      /* read_packed_linearized */read_packed_linearized,
                      /* decode_symbol */decode_symbol,
                      /* n2i */n2i,
                      /* t2i */t2i,
                      /* compare_terminals */compare_terminals,
                      /* compare_nonterminals */compare_nonterminals,
                      /* compare_symbols */compare_symbols,
                      /* compare_productions */compare_productions,
                      /* compare_items */compare_items,
                      /* incoming_symbol */incoming_symbol,
                      /* lhs */lhs,
                      /* rhs */rhs,
                      /* export */$$export,
                      /* items */items,
                      /* decode_bool */decode_bool,
                      /* nullable */nullable,
                      /* first */first,
                      /* xfirst */xfirst,
                      /* foldij */foldij,
                      /* foreach_terminal */foreach_terminal,
                      /* foreach_terminal_but_error */foreach_terminal_but_error,
                      /* feed_failure */feed_failure,
                      /* feed_nonterminal */feed_nonterminal,
                      /* reduce */reduce,
                      /* initiate */initiate,
                      /* feed_terminal */feed_terminal,
                      /* feed */feed
                    ];
            });
        });
    });
}

var InspectionTableInterpreter = /* module */[
  /* Symbols */Symbols,
  /* Make */Make$2
];

function MakeEngineTable(T) {
  var number = function (s) {
    return s;
  };
  var token2terminal = T[/* token2terminal */0];
  var token2value = T[/* token2value */2];
  var error_terminal = T[/* error_terminal */1];
  var foldij = function (_i, j, f, _accu) {
    while(true) {
      var accu = _accu;
      var i = _i;
      if (i === j) {
        return accu;
      } else {
        _accu = Curry._2(f, i, accu);
        _i = i + 1 | 0;
        continue ;
      }
    };
  };
  var foreach_terminal = function (f, accu) {
    var match = T[/* error */4];
    return foldij(0, match[0], Curry.__2(f), accu);
  };
  var non_start_production = function (i) {
    if (T[/* start */8] <= i && (i - T[/* start */8] | 0) < T[/* semantic_action */9].length) {
      return 0;
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              3343,
              4
            ]
          ];
    }
  };
  var production_index = function (i) {
    non_start_production(i);
    return i;
  };
  var find_production = function (i) {
    non_start_production(i);
    return i;
  };
  var default_reduction = function (state, defred, nodefred, env) {
    var code = get$1(T[/* default_reduction */3], state);
    if (code === 0) {
      return Curry._1(nodefred, env);
    } else {
      return Curry._2(defred, env, code - 1 | 0);
    }
  };
  var is_start = function (prod) {
    return prod < T[/* start */8];
  };
  var unmarshal2 = function (table, i, j) {
    return getget(get$1, get$1, table, i, j);
  };
  var action = function (state, terminal, value, shift, reduce, fail, env) {
    var c = unflatten1(T[/* error */4], state, terminal);
    if (c !== 1) {
      if (c !== 0) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "menhirLib.ml",
                3389,
                8
              ]
            ];
      }
      return Curry._1(fail, env);
    } else {
      var action$1 = unmarshal2(T[/* action */5], state, terminal);
      var opcode = action$1 & 3;
      var param = (action$1 >>> 2);
      if (opcode >= 2) {
        var please_discard = opcode === 2;
        return Curry._5(shift, env, please_discard, terminal, value, param);
      } else {
        return Curry._2(reduce, env, param);
      }
    }
  };
  var goto_nt = function (state, nt) {
    var code = unmarshal2(T[/* goto */7], state, nt);
    return code - 1 | 0;
  };
  var goto_prod = function (state, prod) {
    return goto_nt(state, get$1(T[/* lhs */6], prod));
  };
  var maybe_goto_nt = function (state, nt) {
    var code = unmarshal2(T[/* goto */7], state, nt);
    if (0 > code) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "menhirLib.ml",
              3404,
              4
            ]
          ];
    }
    if (code === 0) {
      return undefined;
    } else {
      return code - 1 | 0;
    }
  };
  var $$Error = T[/* Error */10];
  var semantic_action = function (prod) {
    return Caml_array.caml_array_get(T[/* semantic_action */9], prod - T[/* start */8] | 0);
  };
  var may_reduce = function (state, prod) {
    return default_reduction(state, (function (param, prod$prime) {
                  return prod === prod$prime;
                }), (function (param) {
                  return foreach_terminal((function (t, accu) {
                                if (accu) {
                                  return true;
                                } else {
                                  return action(state, t, /* () */0, (function (param, param$1, param$2, param$3, param$4) {
                                                return false;
                                              }), (function (param, prod$prime) {
                                                return prod === prod$prime;
                                              }), (function (param) {
                                                return false;
                                              }), /* () */0);
                                }
                              }), false);
                }), /* () */0);
  };
  var match = T[/* trace */11];
  var log = match !== undefined;
  var state = function (state$1) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Curry._1(Printf.fprintf(Pervasives.stderr, /* Format */[
                      /* String_literal */Block.__(11, [
                          "State ",
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* String_literal */Block.__(11, [
                                  ":\n",
                                  /* Flush */Block.__(10, [/* End_of_format */0])
                                ])
                            ])
                        ]),
                      "State %d:\n%!"
                    ]), state$1);
    } else {
      return /* () */0;
    }
  };
  var shift = function (terminal, state) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Curry._2(Printf.fprintf(Pervasives.stderr, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Shifting (",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  ") to state ",
                                  /* Int */Block.__(4, [
                                      /* Int_d */0,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* Char_literal */Block.__(12, [
                                          /* "\n" */10,
                                          /* Flush */Block.__(10, [/* End_of_format */0])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "Shifting (%s) to state %d\n%!"
                    ]), Caml_array.caml_array_get(match[0], terminal), state);
    } else {
      return /* () */0;
    }
  };
  var reduce_or_accept = function (prod) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Curry._1(Printf.fprintf(Pervasives.stderr, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "\n" */10,
                              /* Flush */Block.__(10, [/* End_of_format */0])
                            ])
                        ]),
                      "%s\n%!"
                    ]), Caml_array.caml_array_get(match[1], prod));
    } else {
      return /* () */0;
    }
  };
  var lookahead_token = function (token, startp, endp) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Curry._3(Printf.fprintf(Pervasives.stderr, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Lookahead token is now ",
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " (",
                                  /* Int */Block.__(4, [
                                      /* Int_d */0,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* Char_literal */Block.__(12, [
                                          /* "-" */45,
                                          /* Int */Block.__(4, [
                                              /* Int_d */0,
                                              /* No_padding */0,
                                              /* No_precision */0,
                                              /* String_literal */Block.__(11, [
                                                  ")\n",
                                                  /* Flush */Block.__(10, [/* End_of_format */0])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ]),
                      "Lookahead token is now %s (%d-%d)\n%!"
                    ]), Caml_array.caml_array_get(match[0], token), startp[/* pos_cnum */3], endp[/* pos_cnum */3]);
    } else {
      return /* () */0;
    }
  };
  var initiating_error_handling = function (param) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Printf.fprintf(Pervasives.stderr, /* Format */[
                  /* String_literal */Block.__(11, [
                      "Initiating error handling\n",
                      /* Flush */Block.__(10, [/* End_of_format */0])
                    ]),
                  "Initiating error handling\n%!"
                ]);
    } else {
      return /* () */0;
    }
  };
  var resuming_error_handling = function (param) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Printf.fprintf(Pervasives.stderr, /* Format */[
                  /* String_literal */Block.__(11, [
                      "Resuming error handling\n",
                      /* Flush */Block.__(10, [/* End_of_format */0])
                    ]),
                  "Resuming error handling\n%!"
                ]);
    } else {
      return /* () */0;
    }
  };
  var handling_error = function (state) {
    var match = T[/* trace */11];
    if (match !== undefined) {
      return Curry._1(Printf.fprintf(Pervasives.stderr, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Handling error in state ",
                          /* Int */Block.__(4, [
                              /* Int_d */0,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* Char_literal */Block.__(12, [
                                  /* "\n" */10,
                                  /* Flush */Block.__(10, [/* End_of_format */0])
                                ])
                            ])
                        ]),
                      "Handling error in state %d\n%!"
                    ]), state);
    } else {
      return /* () */0;
    }
  };
  var Log = /* module */[
    /* state */state,
    /* shift */shift,
    /* reduce_or_accept */reduce_or_accept,
    /* lookahead_token */lookahead_token,
    /* initiating_error_handling */initiating_error_handling,
    /* resuming_error_handling */resuming_error_handling,
    /* handling_error */handling_error
  ];
  return /* module */[
          /* number */number,
          /* token2terminal */token2terminal,
          /* token2value */token2value,
          /* error_terminal */error_terminal,
          /* error_value : () */0,
          /* foldij */foldij,
          /* foreach_terminal */foreach_terminal,
          /* non_start_production */non_start_production,
          /* production_index */production_index,
          /* find_production */find_production,
          /* default_reduction */default_reduction,
          /* is_start */is_start,
          /* unmarshal2 */unmarshal2,
          /* action */action,
          /* goto_nt */goto_nt,
          /* goto_prod */goto_prod,
          /* maybe_goto_nt */maybe_goto_nt,
          /* Error */$$Error,
          /* semantic_action */semantic_action,
          /* may_reduce */may_reduce,
          /* log */log,
          /* Log */Log
        ];
}

var TableInterpreter = /* module */[/* MakeEngineTable */MakeEngineTable];

var StaticVersion = /* module */[/* require_20181113 : () */0];

exports.General = General;
exports.Convert = Convert;
exports.IncrementalEngine = IncrementalEngine;
exports.EngineTypes = EngineTypes;
exports.Engine = Engine;
exports.ErrorReports = ErrorReports;
exports.Printers = Printers;
exports.InfiniteArray = InfiniteArray;
exports.PackedIntArray = PackedIntArray;
exports.RowDisplacement = RowDisplacement;
exports.LinearizedArray = LinearizedArray;
exports.TableFormat = TableFormat;
exports.InspectionTableFormat = InspectionTableFormat;
exports.InspectionTableInterpreter = InspectionTableInterpreter;
exports.TableInterpreter = TableInterpreter;
exports.StaticVersion = StaticVersion;
/* No side effect */
