// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Printf = require("bs-platform/lib/js/printf.js");
var LexerUtil = require("./LexerUtil.bs.js");
var TermLexer = require("./TermLexer.bs.js");
var TermParser = require("./TermParser.bs.js");
var StaticsLexer = require("./StaticsLexer.bs.js");
var DynamicsLexer = require("./DynamicsLexer.bs.js");
var LanguageLexer = require("./LanguageLexer.bs.js");
var StaticsParser = require("./StaticsParser.bs.js");
var DynamicsParser = require("./DynamicsParser.bs.js");
var LanguageParser = require("./LanguageParser.bs.js");
var TermParseErrors = require("./TermParseErrors.bs.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var StaticsParseErrors = require("./StaticsParseErrors.bs.js");
var DynamicsParseErrors = require("./DynamicsParseErrors.bs.js");
var LanguageParseErrors = require("./LanguageParseErrors.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Incremental(M) {
  var I = M[/* MenhirInterpreter */0];
  var stack = function (checkpoint) {
    if (typeof checkpoint === "number") {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "Parsing.ml",
              32,
              11
            ]
          ];
    } else if (checkpoint.tag === 3) {
      return Curry._1(I[/* stack */11], checkpoint[0]);
    } else {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "Parsing.ml",
              32,
              11
            ]
          ];
    }
  };
  var state = function (checkpoint) {
    var lzarg = stack(checkpoint);
    var tag = lzarg.tag | 0;
    var match = tag === 250 ? lzarg[0] : (
        tag === 246 ? CamlinternalLazy.force_lazy_block(lzarg) : lzarg
      );
    if (match) {
      return Curry._1(I[/* number */8], match[0][0]);
    } else {
      return 0;
    }
  };
  var fail = function (lexbuf, c) {
    var s = state(c);
    return /* Error */Block.__(1, [Curry._2(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "Syntax error at offset ",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    ":\n",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* Char_literal */Block.__(12, [
                                            /* "\n" */10,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ])
                          ]),
                        "Syntax error at offset %d:\n%s\n"
                      ]), Lexing.lexeme_start(lexbuf), Curry._1(M[/* ParseErrors */1][/* message */0], s))]);
  };
  var loop = function (lexbuf, result) {
    var supplier = Curry._2(I[/* lexer_lexbuf_to_supplier */2], M[/* Lexer */2][/* read */0], lexbuf);
    try {
      return Curry._4(I[/* loop_handle */4], (function (v) {
                    return /* Ok */Block.__(0, [v]);
                  }), (function (param) {
                    return fail(lexbuf, param);
                  }), supplier, result);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === LexerUtil.$$SyntaxError) {
        return /* Error */Block.__(1, [exn[1]]);
      } else {
        throw exn;
      }
    }
  };
  var parse = function (str) {
    var lexbuf = Lexing.from_string(str);
    return loop(lexbuf, Curry._1(M[/* Parser */3][/* parse */0], lexbuf[/* lex_curr_p */11]));
  };
  return /* module */[
          /* I */I,
          /* stack */stack,
          /* state */state,
          /* fail */fail,
          /* loop */loop,
          /* parse */parse
        ];
}

var parse = TermParser.Incremental[/* top_term */0];

var Parser = /* module */[/* parse */parse];

var Parseable_term_001 = /* ParseErrors : TermParseErrors */[TermParseErrors.message];

var Parseable_term_002 = /* Lexer */[TermLexer.read];

var Parseable_term = /* module */[
  /* MenhirInterpreter */TermParser.MenhirInterpreter,
  Parseable_term_001,
  Parseable_term_002,
  /* Parser */Parser
];

var parse$1 = LanguageParser.Incremental[/* languageDef */0];

var Parser$1 = /* module */[/* parse */parse$1];

var Parseable_language_001 = /* ParseErrors : LanguageParseErrors */[LanguageParseErrors.message];

var Parseable_language_002 = /* Lexer */[LanguageLexer.read];

var Parseable_language = /* module */[
  /* MenhirInterpreter */LanguageParser.MenhirInterpreter,
  Parseable_language_001,
  Parseable_language_002,
  /* Parser */Parser$1
];

var parse$2 = StaticsParser.Incremental[/* rules */1];

var Parser$2 = /* module */[/* parse */parse$2];

var Parseable_statics_001 = /* ParseErrors : StaticsParseErrors */[StaticsParseErrors.message];

var Parseable_statics_002 = /* Lexer */[StaticsLexer.read];

var Parseable_statics = /* module */[
  /* MenhirInterpreter */StaticsParser.MenhirInterpreter,
  Parseable_statics_001,
  Parseable_statics_002,
  /* Parser */Parser$2
];

var parse$3 = DynamicsParser.Incremental[/* dynamics */0];

var Parser$3 = /* module */[/* parse */parse$3];

var Parseable_dynamics_001 = /* ParseErrors : DynamicsParseErrors */[DynamicsParseErrors.message];

var Parseable_dynamics_002 = /* Lexer */[DynamicsLexer.read];

var Parseable_dynamics = /* module */[
  /* MenhirInterpreter */DynamicsParser.MenhirInterpreter,
  Parseable_dynamics_001,
  Parseable_dynamics_002,
  /* Parser */Parser$3
];

exports.Incremental = Incremental;
exports.Parseable_term = Parseable_term;
exports.Parseable_language = Parseable_language;
exports.Parseable_statics = Parseable_statics;
exports.Parseable_dynamics = Parseable_dynamics;
/* TermParser Not a pure module */
