// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Types = require("./types.bs.js");
var React = require("react");
var Bigint = require("bs-zarith/src/Bigint.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Parsing = require("bs-platform/lib/js/parsing.js");
var TermLexer = require("./termLexer.bs.js");
var ReactDOMRe = require("reason-react/src/ReactDOMRe.js");
var TermParser = require("./termParser.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function show_term(term) {
  switch (term.tag | 0) {
    case 0 : 
        return Block.spliceApply(React.createElement, [
                    "span",
                    { },
                    $$Array.concat(/* :: */[
                          /* array */[term[0]],
                          /* :: */[
                            /* array */["("],
                            /* :: */[
                              $$Array.of_list(List.map(show_scope, term[1])),
                              /* :: */[
                                /* array */[")"],
                                /* [] */0
                              ]
                            ]
                          ]
                        ])
                  ]);
    case 1 : 
        return term[0];
    case 2 : 
        return Block.spliceApply(React.createElement, [
                    "span",
                    { },
                    $$Array.concat(/* :: */[
                          /* array */["["],
                          /* :: */[
                            $$Array.of_list(List.map(show_term, term[0])),
                            /* :: */[
                              /* array */["]"],
                              /* [] */0
                            ]
                          ]
                        ])
                  ]);
    case 3 : 
        return show_prim(term[0]);
    
  }
}

function show_scope(scope) {
  return Block.spliceApply(React.createElement, [
              "span",
              { },
              $$Array.concat(/* :: */[
                    $$Array.of_list(Types.intersperse_after(List.map((function (prim) {
                                    return prim;
                                  }), scope[0]), ".")),
                    /* :: */[
                      /* array */[show_term(scope[1])],
                      /* [] */0
                    ]
                  ])
            ]);
}

function show_prim(prim) {
  switch (prim.tag | 0) {
    case 0 : 
        return Bigint.to_string(prim[0]);
    case 1 : 
        return prim[0];
    case 2 : 
        if (prim[0]) {
          return "true";
        } else {
          return "false";
        }
    
  }
}

function Index$TermViewer(Props) {
  var term = Props.term;
  return React.createElement("div", undefined, show_term(term));
}

var TermViewer = /* module */[
  /* show_term */show_term,
  /* show_scope */show_scope,
  /* show_prim */show_prim,
  /* make */Index$TermViewer
];

function Index$LvcaViewer(Props) {
  var match = React.useState((function () {
          return "";
        }));
  var setTermInput = match[1];
  var termInput = match[0];
  var match$1 = React.useState((function () {
          return "";
        }));
  var setLanguageDefinition = match$1[1];
  var match$2 = React.useState((function () {
          return "";
        }));
  var setStaticsDefinition = match$2[1];
  var match$3 = React.useState((function () {
          return "";
        }));
  var setDynamicsDefinition = match$3[1];
  var termResult;
  var exit = 0;
  var term;
  try {
    term = TermParser.term(TermLexer.read, Lexing.from_string(termInput));
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === TermLexer.$$SyntaxError) {
      termResult = /* Error */Block.__(1, [exn[1]]);
    } else if (exn === Parsing.Parse_error) {
      termResult = /* Error */Block.__(1, ["Parse error"]);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    termResult = /* Ok */Block.__(0, [term]);
  }
  var termView;
  termView = termResult.tag ? React.createElement("div", {
          className: "error"
        }, termResult[0]) : React.createElement(Index$TermViewer, {
          term: termResult[0]
        });
  return React.createElement("div", undefined, React.createElement("h1", undefined, "LVCA"), React.createElement("h2", undefined, "Language Definition"), React.createElement("textarea", {
                  value: match$1[0],
                  onChange: (function ($$event) {
                      return Curry._1(setLanguageDefinition, $$event.target.value);
                    })
                }), React.createElement("h2", undefined, "Statics"), React.createElement("textarea", {
                  value: match$2[0],
                  onChange: (function ($$event) {
                      return Curry._1(setStaticsDefinition, $$event.target.value);
                    })
                }), React.createElement("h2", undefined, "Dynamics"), React.createElement("textarea", {
                  value: match$3[0],
                  onChange: (function ($$event) {
                      return Curry._1(setDynamicsDefinition, $$event.target.value);
                    })
                }), React.createElement("h2", undefined, "Input"), React.createElement("textarea", {
                  value: termInput,
                  onChange: (function ($$event) {
                      return Curry._1(setTermInput, $$event.target.value);
                    })
                }), termView);
}

var LvcaViewer = /* module */[/* make */Index$LvcaViewer];

ReactDOMRe.renderToElementWithId(React.createElement(Index$LvcaViewer, { }), "index");

exports.TermViewer = TermViewer;
exports.LvcaViewer = LvcaViewer;
/*  Not a pure module */
