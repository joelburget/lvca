// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Util = require("./util.bs.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Types = require("./types.bs.js");
var React = require("react");
var Bigint = require("bs-zarith/src/Bigint.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Parsing = require("bs-platform/lib/js/parsing.js");
var LexerUtil = require("./lexerUtil.bs.js");
var TermLexer = require("./termLexer.bs.js");
var ReactDOMRe = require("reason-react/src/ReactDOMRe.js");
var TermParser = require("./termParser.bs.js");
var LvcaMode = require("./lvca-mode");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var StaticsLexer = require("./staticsLexer.bs.js");
var DynamicsLexer = require("./dynamicsLexer.bs.js");
var LanguageLexer = require("./languageLexer.bs.js");
var StaticsParser = require("./staticsParser.bs.js");
var DynamicsParser = require("./dynamicsParser.bs.js");
var LanguageParser = require("./languageParser.bs.js");
var LanguageSimple = require("./languageSimple.bs.js");
var ReactCodemirror = require("react-codemirror");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function show_prim(prim) {
  switch (prim.tag | 0) {
    case 0 : 
        return Bigint.to_string(prim[0]);
    case 1 : 
        return "\"" + (prim[0] + "\"");
    case 2 : 
        if (prim[0]) {
          return "true";
        } else {
          return "false";
        }
    
  }
}

var CodeMirror = /* module */[];

function Index$Repl(Props) {
  var input = Props.input;
  var setInput = Props.setInput;
  var options = {
    mode: "lvca"
  };
  return React.createElement(ReactCodemirror, {
              value: input,
              onChange: setInput,
              options: options
            });
}

var Repl = /* module */[/* make */Index$Repl];

function make_span(children) {
  return Block.spliceApply(React.createElement, [
              "span",
              { },
              $$Array.concat(children)
            ]);
}

function show_term(term) {
  switch (term.tag | 0) {
    case 0 : 
        return make_span(/* :: */[
                    /* array */[term[0]],
                    /* :: */[
                      /* array */["("],
                      /* :: */[
                        $$Array.of_list(Util.intersperse(List.map(show_scope, term[1]), ";")),
                        /* :: */[
                          /* array */[")"],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]);
    case 1 : 
        return String(term[0]);
    case 2 : 
        return make_span(/* :: */[
                    /* array */["["],
                    /* :: */[
                      $$Array.of_list(List.map(show_term, term[0])),
                      /* :: */[
                        /* array */["]"],
                        /* [] */0
                      ]
                    ]
                  ]);
    case 3 : 
        return show_prim(term[0]);
    
  }
}

function show_scope(scope) {
  return make_span(/* :: */[
              $$Array.of_list(Util.intersperse_after(List.map((function (prim) {
                              return prim;
                            }), scope[0]), ".")),
              /* :: */[
                /* array */[show_term(scope[1])],
                /* [] */0
              ]
            ]);
}

function Index$TermViewer(Props) {
  var term = Props.term;
  return React.createElement("div", undefined, show_term(term));
}

var TermViewer = /* module */[
  /* show_term */show_term,
  /* show_scope */show_scope,
  /* make */Index$TermViewer
];

function view_core_val(coreVal) {
  switch (coreVal.tag | 0) {
    case 0 : 
        return make_span(/* :: */[
                    /* array */[coreVal[0]],
                    /* :: */[
                      $$Array.of_list(Util.intersperse(List.map(view_core_val, coreVal[1]), "; ")),
                      /* [] */0
                    ]
                  ]);
    case 1 : 
        return show_prim(coreVal[0]);
    case 2 : 
        return coreVal[0];
    case 3 : 
        return make_span(/* :: */[
                    $$Array.of_list(Util.intersperse(List.map((function (prim) {
                                    return prim;
                                  }), coreVal[0]), ". ")),
                    /* :: */[
                      /* array */[view_core(coreVal[1])],
                      /* [] */0
                    ]
                  ]);
    
  }
}

function view_core(core) {
  switch (core.tag | 0) {
    case 0 : 
        return core[0];
    case 1 : 
        return view_core_val(core[0]);
    case 2 : 
        return make_span(/* :: */[
                    /* array */["app("],
                    /* :: */[
                      /* array */[view_core(core[0])],
                      /* :: */[
                        /* array */["; "],
                        /* :: */[
                          $$Array.of_list(Util.intersperse(List.map(view_core, core[1]), "; ")),
                          /* :: */[
                            /* array */[")"],
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]);
    case 3 : 
        return make_span(/* :: */[
                    /* array */["lam("],
                    /* :: */[
                      $$Array.of_list(Util.intersperse(List.map((function (prim) {
                                      return prim;
                                    }), core[0]), ". ")),
                      /* :: */[
                        /* array */[view_core(core[1])],
                        /* :: */[
                          /* array */[")"],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]);
    case 4 : 
        return make_span(/* :: */[
                    /* array */["case("],
                    /* :: */[
                      /* array */[view_core(core[0])],
                      /* :: */[
                        /* array */["; ...)"],
                        /* [] */0
                      ]
                    ]
                  ]);
    case 5 : 
        return make_span(/* :: */[
                    /* array */["[["],
                    /* :: */[
                      /* array */[core[0]],
                      /* :: */[
                        /* array */["]]"],
                        /* [] */0
                      ]
                    ]
                  ]);
    
  }
}

function view_core_pat(pat) {
  if (typeof pat === "number") {
    return "default";
  } else {
    switch (pat.tag | 0) {
      case 0 : 
          return React.createElement("span", undefined, pat[0] + "(", ")");
      case 1 : 
          var match = pat[0];
          if (match !== undefined) {
            return match;
          } else {
            return "_";
          }
      case 2 : 
          return show_prim(pat[0]);
      
    }
  }
}

function Index$CoreValView(Props) {
  var coreVal = Props.coreVal;
  return React.createElement("div", undefined, view_core_val(coreVal));
}

var CoreValView = /* module */[
  /* view_core_pat */view_core_pat,
  /* view_core */view_core,
  /* view_core_val */view_core_val,
  /* make */Index$CoreValView
];

function Index$ParseStatus$Component(Props) {
  var result = Props.result;
  if (result.tag) {
    return React.createElement("span", {
                className: "result-bad"
              }, result[0]);
  } else {
    return React.createElement("span", {
                className: "result-good"
              }, "(good)");
  }
}

var Component = /* module */[/* make */Index$ParseStatus$Component];

function parse(runParse, read, lexbuf) {
  var result;
  var exit = 0;
  var parsed;
  try {
    parsed = Curry._2(runParse, read, lexbuf);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === LexerUtil.$$SyntaxError) {
      result = /* Error */Block.__(1, [exn[1]]);
    } else {
      var pos = lexbuf[/* lex_curr_p */11];
      var tok = Lexing.lexeme(lexbuf);
      result = /* Error */Block.__(1, [Curry._4(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "Parse error (",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                ") ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* Char_literal */Block.__(12, [
                                        /* ":" */58,
                                        /* Int */Block.__(4, [
                                            /* Int_d */0,
                                            /* No_padding */0,
                                            /* No_precision */0,
                                            /* Char_literal */Block.__(12, [
                                                /* ":" */58,
                                                /* Int */Block.__(4, [
                                                    /* Int_d */0,
                                                    /* No_padding */0,
                                                    /* No_precision */0,
                                                    /* End_of_format */0
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ]),
                    "Parse error (%s) %s:%d:%d"
                  ]), tok, pos[/* pos_fname */0], pos[/* pos_lnum */1], (pos[/* pos_cnum */3] - pos[/* pos_bol */2] | 0) + 1 | 0)]);
    }
  }
  if (exit === 1) {
    result = /* Ok */Block.__(0, [parsed]);
  }
  return /* tuple */[
          React.createElement(Index$ParseStatus$Component, {
                result: result
              }),
          result
        ];
}

var ParseStatus = /* module */[
  /* Component */Component,
  /* parse */parse
];

function Index$LvcaViewer(Props) {
  var match = React.useState((function () {
          return "val(true())";
        }));
  var setTermInput = match[1];
  var termInput = match[0];
  var match$1 = React.useState((function () {
          return LanguageSimple.abstractSyntax;
        }));
  var setAsInput = match$1[1];
  var asInput = match$1[0];
  var match$2 = React.useState((function () {
          return LanguageSimple.statics;
        }));
  var setStaticsInput = match$2[1];
  var staticsInput = match$2[0];
  var match$3 = React.useState((function () {
          return LanguageSimple.dynamics;
        }));
  var setDynamicsInput = match$3[1];
  var dynamicsInput = match$3[0];
  var match$4 = parse(LanguageParser.languageDef, LanguageLexer.read, Lexing.from_string(asInput));
  var language = match$4[1];
  var match$5 = parse(StaticsParser.rules, StaticsLexer.read, Lexing.from_string(staticsInput));
  var match$6 = parse(DynamicsParser.dynamics, DynamicsLexer.read, Lexing.from_string(dynamicsInput));
  var dynamics = match$6[1];
  var show_term_pane = Belt_Result.isOk(language) && Belt_Result.isOk(match$5[1]) && Belt_Result.isOk(dynamics);
  var termResult;
  var exit = 0;
  var term;
  try {
    term = TermParser.term(TermLexer.read, Lexing.from_string(termInput));
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === LexerUtil.$$SyntaxError) {
      termResult = /* Error */Block.__(1, [exn[1]]);
    } else if (exn === Parsing.Parse_error || exn === TermParser.$$Error) {
      termResult = /* Error */Block.__(1, ["Parse error"]);
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    termResult = Curry._3(Types.Abt[/* from_ast */0], Belt_Result.getExn(language), "tm", term);
  }
  var evalResult;
  if (dynamics.tag) {
    evalResult = /* Error */Block.__(1, [/* tuple */[
          dynamics[0],
          undefined
        ]]);
  } else if (termResult.tag) {
    evalResult = /* Error */Block.__(1, [/* tuple */[
          termResult[0],
          undefined
        ]]);
  } else {
    var termResult_ = termResult[0];
    var match$7 = Types.Core[/* term_to_core */10](dynamics[0], termResult_);
    if (match$7.tag) {
      evalResult = /* Error */Block.__(1, [match$7[0]]);
    } else {
      var match$8 = Types.Core[/* eval */11](match$7[0]);
      evalResult = match$8.tag ? /* Error */Block.__(1, [/* tuple */[
              match$8[0],
              termResult_
            ]]) : /* Ok */Block.__(0, [match$8[0]]);
    }
  }
  var evalView;
  if (evalResult.tag) {
    var match$9 = evalResult[0];
    var match$10 = match$9[1];
    var msg = match$9[0];
    evalView = match$10 !== undefined ? React.createElement("div", {
            className: "error"
          }, msg, React.createElement(Index$TermViewer, {
                term: match$10
              })) : React.createElement("div", {
            className: "error"
          }, msg);
  } else {
    evalView = React.createElement(Index$CoreValView, {
          coreVal: evalResult[0]
        });
  }
  var replPane = show_term_pane ? React.createElement("div", {
          className: "repl-pane"
        }, React.createElement("div", {
              className: "term-input"
            }, React.createElement(Index$Repl, {
                  input: termInput,
                  setInput: (function (str) {
                      return Curry._1(setTermInput, (function (param) {
                                    return str;
                                  }));
                    })
                })), React.createElement("div", {
              className: "term-view"
            }, evalView)) : React.createElement("div", {
          className: "repl-pane disabled"
        });
  return React.createElement("div", {
              className: "lvca-viewer"
            }, React.createElement("h1", {
                  className: "header"
                }, "LVCA"), React.createElement("h2", {
                  className: "header2 header2-abstract-syntax"
                }, "Abstract Syntax ", match$4[0]), React.createElement("div", {
                  className: "abstract-syntax-pane"
                }, React.createElement(ReactCodemirror, {
                      value: asInput,
                      onChange: (function (str) {
                          return Curry._1(setAsInput, (function (param) {
                                        return str;
                                      }));
                        }),
                      options: {
                        mode: "default"
                      }
                    })), React.createElement("h2", {
                  className: "header2 header2-statics"
                }, "Statics ", match$5[0]), React.createElement("div", {
                  className: "statics-pane"
                }, React.createElement(ReactCodemirror, {
                      value: staticsInput,
                      onChange: (function (str) {
                          return Curry._1(setStaticsInput, (function (param) {
                                        return str;
                                      }));
                        }),
                      options: {
                        mode: "default"
                      }
                    })), React.createElement("h2", {
                  className: "header2 header2-dynamics"
                }, "Dynamics ", match$6[0]), React.createElement("div", {
                  className: "dynamics-pane"
                }, React.createElement(ReactCodemirror, {
                      value: dynamicsInput,
                      onChange: (function (str) {
                          return Curry._1(setDynamicsInput, (function (param) {
                                        return str;
                                      }));
                        }),
                      options: {
                        mode: "default"
                      }
                    })), React.createElement("h2", {
                  className: "header2 header2-repl"
                }, "repl"), replPane);
}

var LvcaViewer = /* module */[/* make */Index$LvcaViewer];

ReactDOMRe.renderToElementWithId(React.createElement(Index$LvcaViewer, { }), "index");

var _modeImport = /* () */0;

exports._modeImport = _modeImport;
exports.show_prim = show_prim;
exports.CodeMirror = CodeMirror;
exports.Repl = Repl;
exports.make_span = make_span;
exports.TermViewer = TermViewer;
exports.CoreValView = CoreValView;
exports.ParseStatus = ParseStatus;
exports.LvcaViewer = LvcaViewer;
/*  Not a pure module */
