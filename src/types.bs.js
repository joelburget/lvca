// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Bigint = require("bs-zarith/src/Bigint.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Caml_module = require("bs-platform/lib/js/caml_module.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function intersperse(list, el) {
  if (list) {
    var match = list[1];
    if (match) {
      return /* :: */[
              list[0],
              /* :: */[
                el,
                intersperse(/* :: */[
                      match[0],
                      match[1]
                    ], el)
              ]
            ];
    } else {
      return list;
    }
  } else {
    return list;
  }
}

function intersperse_after(list, el) {
  if (list) {
    var match = list[1];
    var list_el = list[0];
    if (match) {
      return /* :: */[
              list_el,
              /* :: */[
                el,
                intersperse_after(/* :: */[
                      match[0],
                      match[1]
                    ], el)
              ]
            ];
    } else {
      return /* :: */[
              list_el,
              /* :: */[
                el,
                /* [] */0
              ]
            ];
    }
  } else {
    return /* [] */0;
  }
}

function get_first(f, _lst) {
  while(true) {
    var lst = _lst;
    if (lst) {
      var some_b = Curry._1(f, lst[0]);
      if (some_b !== undefined) {
        return some_b;
      } else {
        _lst = lst[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function traverse_list_result(lst) {
  if (lst) {
    var match = lst[0];
    if (match.tag) {
      return /* Error */Block.__(1, [match[0]]);
    } else {
      var match$1 = traverse_list_result(lst[1]);
      if (match$1.tag) {
        return /* Error */Block.__(1, [match$1[0]]);
      } else {
        return /* Ok */Block.__(0, [/* :: */[
                    match[0],
                    match$1[0]
                  ]]);
      }
    }
  } else {
    return /* Ok */Block.__(0, [/* [] */0]);
  }
}

function union(m1, m2) {
  return Belt_MapString.merge(m1, m2, (function (_k, v1, v2) {
                if (v2 !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(v2));
                } else if (v1 !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(v1));
                } else {
                  return undefined;
                }
              }));
}

function fold_right(f, lst, b) {
  if (lst) {
    return Curry._1(f, /* tuple */[
                lst[0],
                fold_right(f, lst[1], b)
              ]);
  } else {
    return b;
  }
}

function prim_eq(p1, p2) {
  switch (p1.tag | 0) {
    case 0 : 
        switch (p2.tag | 0) {
          case 0 : 
              return Bigint.$eq(p1[0], p2[0]);
          case 1 : 
          case 2 : 
              return false;
          
        }
    case 1 : 
        switch (p2.tag | 0) {
          case 1 : 
              return p1[0] === p2[0];
          case 0 : 
          case 2 : 
              return false;
          
        }
    case 2 : 
        switch (p2.tag | 0) {
          case 0 : 
          case 1 : 
              return false;
          case 2 : 
              return p1[0] === p2[0];
          
        }
    
  }
}

var Abt = Caml_module.init_mod([
      "types.ml",
      115,
      6
    ], [[
        0,
        0,
        0
      ]]);

var Ast = Caml_module.init_mod([
      "types.ml",
      191,
      6
    ], [[0]]);

function find_operator(_operators, tag) {
  while(true) {
    var operators = _operators;
    if (operators) {
      var od = operators[0];
      if (od[0] === tag) {
        return od;
      } else {
        _operators = operators[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function from_ast_with_bindings(lang, current_sort, env, param) {
  switch (param.tag | 0) {
    case 0 : 
        var subtms = param[1];
        var tag = param[0];
        var match = Belt_MapString.get(lang[0], current_sort);
        if (match !== undefined) {
          var match$1 = find_operator(match[1], tag);
          if (match$1 !== undefined) {
            var valences = match$1[1][1];
            if (Belt_List.length(valences) !== Belt_List.length(subtms)) {
              return /* Error */Block.__(1, ["TODO"]);
            } else {
              var x = traverse_list_result(Belt_List.map(Belt_List.zip(valences, subtms), (function (param) {
                          var valence = param[0];
                          if (valence.tag) {
                            return /* Error */Block.__(1, ["TODO"]);
                          } else {
                            var match = valence[1];
                            if (match.tag) {
                              return scope_from_ast(lang, match[0], env, param[1]);
                            } else {
                              return /* Error */Block.__(1, ["TODO"]);
                            }
                          }
                        })));
              if (x.tag) {
                return /* Error */Block.__(1, [x[0]]);
              } else {
                return /* Ok */Block.__(0, [/* Term */Block.__(0, [
                              tag,
                              x[0]
                            ])]);
              }
            }
          } else {
            return /* Error */Block.__(1, ["from_ast_with_bindings: couldn't find operator " + (tag + (" (in sort " + (current_sort + ")")))]);
          }
        } else {
          return /* Error */Block.__(1, ["from_ast_with_bindings: couldn't find sort " + current_sort]);
        }
    case 1 : 
        var name = param[0];
        var match$2 = Belt_MapString.get(env, name);
        if (match$2 !== undefined) {
          return /* Ok */Block.__(0, [/* Var */Block.__(1, [match$2])]);
        } else {
          return /* Error */Block.__(1, ["couldn't find variable " + name]);
        }
    case 2 : 
        var x$1 = traverse_list_result(Belt_List.map(param[0], (function (param) {
                    return from_ast_with_bindings(lang, current_sort, env, param);
                  })));
        return Belt_Result.map(x$1, (function (x$prime) {
                      return /* Sequence */Block.__(2, [x$prime]);
                    }));
    case 3 : 
        return /* Ok */Block.__(0, [/* Primitive */Block.__(3, [param[0]])]);
    
  }
}

function scope_from_ast(lang, current_sort, env, param) {
  var names = param[0];
  return Belt_Result.map(from_ast_with_bindings(lang, current_sort, env, param[1]), (function (body$prime) {
                return /* Scope */[
                        names,
                        body$prime
                      ];
              }));
}

function from_ast(lang, current_sort) {
  return (function (param) {
      return from_ast_with_bindings(lang, current_sort, Belt_MapString.empty, param);
    });
}

Caml_module.update_mod([[
        0,
        0,
        0
      ]], Abt, /* module */[
      /* from_ast */from_ast,
      /* from_ast_with_bindings */from_ast_with_bindings,
      /* scope_from_ast */scope_from_ast
    ]);

function from_abt(param) {
  if (param.tag === 1) {
    return /* Error */Block.__(1, ["TODO 3"]);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "types.ml",
            202,
            21
          ]
        ];
  }
}

Caml_module.update_mod([[0]], Ast, /* module */[/* from_abt */from_abt]);

function matchBranch(v, pat) {
  var exit = 0;
  switch (v.tag | 0) {
    case 0 : 
        var vals = v[1];
        if (typeof pat === "number") {
          exit = 1;
        } else {
          switch (pat.tag | 0) {
            case 0 : 
                var pats = pat[1];
                var subResults = Belt_List.map(Belt_List.zip(vals, pats), (function (param) {
                        return matchBranch(param[0], param[1]);
                      }));
                if (v[0] === pat[0] && Belt_List.length(vals) === Belt_List.length(pats) && Belt_List.every(subResults, Belt_Option.isSome)) {
                  return Caml_option.some(Belt_List.reduce(subResults, Belt_MapString.empty, (function (m, m$prime) {
                                    return Belt_MapString.merge(m, Belt_Option.getExn(m$prime), (function (_k, v1, v2) {
                                                  if (v2 !== undefined) {
                                                    return v2;
                                                  } else if (v1 !== undefined) {
                                                    return v1;
                                                  } else {
                                                    return undefined;
                                                  }
                                                }));
                                  })));
                } else {
                  return undefined;
                }
            case 1 : 
                exit = 1;
                break;
            case 2 : 
                return undefined;
            
          }
        }
        break;
    case 1 : 
        if (typeof pat === "number") {
          exit = 1;
        } else {
          switch (pat.tag | 0) {
            case 0 : 
                return undefined;
            case 1 : 
                exit = 1;
                break;
            case 2 : 
                if (prim_eq(v[0], pat[0])) {
                  return Caml_option.some(Belt_MapString.empty);
                } else {
                  return undefined;
                }
            
          }
        }
        break;
    case 2 : 
    case 3 : 
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    if (typeof pat === "number") {
      return Caml_option.some(Belt_MapString.empty);
    } else {
      switch (pat.tag | 0) {
        case 1 : 
            var match = pat[0];
            if (match !== undefined) {
              return Caml_option.some(Belt_MapString.fromArray(/* array */[/* tuple */[
                                match,
                                v
                              ]]));
            } else {
              return Caml_option.some(Belt_MapString.empty);
            }
        case 0 : 
        case 2 : 
            return undefined;
        
      }
    }
  }
  
}

function matches(tm, pat) {
  var exit = 0;
  if (tm.tag) {
    exit = 1;
  } else {
    var subtms = tm[1];
    if (pat.tag) {
      exit = 1;
    } else {
      var subpats = pat[1];
      if (tm[0] === pat[0] && Belt_List.length(subtms) === Belt_List.length(subpats)) {
        return fold_right((function (param) {
                      var b_opt = param[1];
                      var match = param[0];
                      var match$1 = matches_scope(match[0], match[1]);
                      if (match$1 !== undefined && b_opt !== undefined) {
                        var match$2 = b_opt;
                        var match$3 = match$1;
                        return /* tuple */[
                                Pervasives.$at(match$3[0], match$2[0]),
                                union(match$3[1], match$2[1])
                              ];
                      }
                      
                    }), Belt_List.zip(subtms, subpats), /* tuple */[
                    /* [] */0,
                    Belt_MapString.empty
                  ]);
      } else {
        return undefined;
      }
    }
  }
  if (exit === 1) {
    if (pat.tag) {
      var match = pat[0];
      if (match !== undefined) {
        return /* tuple */[
                /* [] */0,
                Belt_MapString.fromArray(/* array */[/* tuple */[
                        match,
                        tm
                      ]])
              ];
      } else {
        return /* tuple */[
                /* [] */0,
                Belt_MapString.empty
              ];
      }
    } else {
      return undefined;
    }
  }
  
}

function matches_scope(scope, pat) {
  var patBinders = pat[0];
  var binders = scope[0];
  if (Belt_List.length(patBinders) === Belt_List.length(binders)) {
    return Belt_Option.map(matches(scope[1], pat[1]), (function (param) {
                  return /* tuple */[
                          Pervasives.$at(Belt_List.zip(patBinders, binders), param[0]),
                          param[1]
                        ];
                }));
  }
  
}

function find_match(dynamics, term) {
  return get_first((function (param) {
                var match = matches(term, param[0]);
                if (match !== undefined) {
                  var match$1 = match;
                  return /* tuple */[
                          match$1[0],
                          match$1[1],
                          param[1]
                        ];
                }
                
              }), dynamics[0]);
}

function fill_in_core(dynamics, mr, c) {
  switch (c.tag | 0) {
    case 0 : 
        return /* Ok */Block.__(0, [c]);
    case 1 : 
        return Belt_Result.map(fill_in_val(dynamics, mr, c[0]), (function (v$prime) {
                      return /* CoreVal */Block.__(1, [v$prime]);
                    }));
    case 2 : 
        var match = fill_in_core(dynamics, mr, c[0]);
        var match$1 = traverse_list_result(Belt_List.map(c[1], (function (param) {
                    return fill_in_core(dynamics, mr, param);
                  })));
        if (match.tag) {
          return /* Error */Block.__(1, [match[0]]);
        } else if (match$1.tag) {
          return /* Error */Block.__(1, [match$1[0]]);
        } else {
          return /* Ok */Block.__(0, [/* CoreApp */Block.__(2, [
                        match[0],
                        match$1[0]
                      ])]);
        }
    case 3 : 
        var binders = c[0];
        return Belt_Result.map(fill_in_core(dynamics, mr, c[1]), (function (core$prime) {
                      return /* Lam */Block.__(3, [
                                binders,
                                core$prime
                              ]);
                    }));
    case 4 : 
        var x = traverse_list_result(Belt_List.map(c[2], (function (param) {
                    var pat = param[0];
                    return Belt_Result.map(fill_in_core(dynamics, mr, param[1]), (function (core$prime) {
                                  return /* tuple */[
                                          pat,
                                          core$prime
                                        ];
                                }));
                  })));
        var match$2 = fill_in_core(dynamics, mr, c[0]);
        if (match$2.tag) {
          return /* Error */Block.__(1, [match$2[0]]);
        } else if (x.tag) {
          return /* Error */Block.__(1, [x[0]]);
        } else {
          return /* Ok */Block.__(0, [/* Case */Block.__(4, [
                        match$2[0],
                        c[1],
                        x[0]
                      ])]);
        }
    case 5 : 
        var match$3 = Belt_MapString.get(mr[1], c[0]);
        if (match$3 !== undefined) {
          return term_to_core(dynamics, match$3);
        } else {
          return /* Error */Block.__(1, [/* tuple */[
                      "TODO 4",
                      undefined
                    ]]);
        }
    
  }
}

function fill_in_val(dynamics, mr, v) {
  switch (v.tag | 0) {
    case 0 : 
        var tag = v[0];
        return Belt_Result.map(traverse_list_result(Belt_List.map(v[1], (function (param) {
                              return fill_in_val(dynamics, mr, param);
                            }))), (function (vals$prime) {
                      return /* ValTm */Block.__(0, [
                                tag,
                                vals$prime
                              ]);
                    }));
    case 1 : 
    case 2 : 
        return /* Ok */Block.__(0, [v]);
    case 3 : 
        var binders = v[0];
        return Belt_Result.map(fill_in_core(dynamics, mr, v[1]), (function (core$prime) {
                      return /* ValLam */Block.__(3, [
                                binders,
                                core$prime
                              ]);
                    }));
    
  }
}

function term_to_core(dynamics, tm) {
  var match = find_match(dynamics, tm);
  if (match !== undefined) {
    var match$1 = match;
    return fill_in_core(dynamics, /* tuple */[
                match$1[0],
                match$1[1]
              ], match$1[2]);
  } else {
    return /* Error */Block.__(1, [/* tuple */[
                "no match found",
                tm
              ]]);
  }
}

function $$eval(core) {
  var _ctx = Belt_MapString.empty;
  var _core = core;
  while(true) {
    var core$1 = _core;
    var ctx = _ctx;
    switch (core$1.tag | 0) {
      case 0 : 
          var v = core$1[0];
          var match = Belt_MapString.get(ctx, v);
          if (match !== undefined) {
            return /* Ok */Block.__(0, [match]);
          } else {
            return /* Error */Block.__(1, ["Unbound variable " + v]);
          }
      case 1 : 
          return /* Ok */Block.__(0, [core$1[0]]);
      case 2 : 
          var match$1 = core$1[0];
          if (match$1.tag === 3) {
            var argNames = match$1[0];
            if (Belt_List.length(argNames) !== Belt_List.length(core$1[1])) {
              return /* Error */Block.__(1, ["mismatched application lengths"]);
            } else {
              var ctx$prime = Belt_MapString.merge(ctx, Belt_MapString.fromArray(Belt_List.toArray(Belt_List.zip(argNames, /* [] */0))), (function (_k, v1, v2) {
                      if (v2 !== undefined) {
                        return v2;
                      } else if (v1 !== undefined) {
                        return v1;
                      } else {
                        return undefined;
                      }
                    }));
              _core = match$1[1];
              _ctx = ctx$prime;
              continue ;
            }
          } else {
            return /* Error */Block.__(1, ["TODO 5"]);
          }
      case 3 : 
      case 4 : 
          return /* Error */Block.__(1, ["TODO 5"]);
      case 5 : 
          return /* Error */Block.__(1, ["Found a metavar!"]);
      
    }
  };
}

var Core = /* module */[
  /* M */0,
  /* O */0,
  /* matchBranch */matchBranch,
  /* matches */matches,
  /* matches_scope */matches_scope,
  /* find_match */find_match,
  /* fill_in_core */fill_in_core,
  /* fill_in_val */fill_in_val,
  /* term_to_core */term_to_core,
  /* eval */$$eval
];

var Statics = /* module */[/* M */0];

exports.intersperse = intersperse;
exports.intersperse_after = intersperse_after;
exports.get_first = get_first;
exports.traverse_list_result = traverse_list_result;
exports.union = union;
exports.fold_right = fold_right;
exports.prim_eq = prim_eq;
exports.Abt = Abt;
exports.Ast = Ast;
exports.Core = Core;
exports.Statics = Statics;
/* Abt Not a pure module */
