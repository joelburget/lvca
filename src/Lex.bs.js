// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Belt_MutableMapInt = require("bs-platform/lib/js/belt_MutableMapInt.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var LexError = Caml_exceptions.create("Lex.LexError");

var FoundFirstCapture = Caml_exceptions.create("Lex.FoundFirstCapture");

function find_first_capture(tok_names, captures) {
  try {
    for(var i = 1 ,i_finish = captures.length - 1 | 0; i <= i_finish; ++i){
      if (!(Caml_array.caml_array_get(captures, i) == null)) {
        throw [
              FoundFirstCapture,
              i - 1 | 0
            ];
      }
      
    }
    return undefined;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === FoundFirstCapture) {
      return Belt_MapInt.getExn(tok_names, exn[1]);
    } else {
      throw exn;
    }
  }
}

function get_next_tok(tok_names, re, param) {
  var pos = param[/* pos */1];
  var param$1 = re.exec(param[/* buf */0].slice(pos[/* character */1]));
  if (param$1 !== null) {
    var match = Caml_array.caml_array_get(param$1, 0);
    var match$1 = find_first_capture(tok_names, param$1);
    if (match == null) {
      throw [
            LexError,
            /* record */[
              /* start_pos */pos,
              /* end_pos */pos,
              /* message */"TODO 1"
            ]
          ];
    } else if (match$1 !== undefined) {
      return /* record */[
              /* name */match$1,
              /* start */pos[/* character */1],
              /* finish */pos[/* character */1] + match.length | 0
            ];
    } else {
      throw [
            LexError,
            /* record */[
              /* start_pos */pos,
              /* end_pos */pos,
              /* message */"TODO 1"
            ]
          ];
    }
  } else {
    throw [
          LexError,
          /* record */[
            /* start_pos */pos,
            /* end_pos */pos,
            /* message */"TODO 2"
          ]
        ];
  }
}

function lex$prime(lexer, input) {
  var result = /* array */[];
  var lexbuf = /* record */[
    /* buf */input,
    /* pos : record */[
      /* line */0,
      /* character */0
    ]
  ];
  var mut_tok_names = Belt_MutableMapInt.make(/* () */0);
  var re_str = Belt_Array.mapWithIndex(Belt_List.toArray(lexer), (function (i, param) {
            Belt_MutableMapInt.set(mut_tok_names, i, param[1]);
            return "(" + (param[0] + ")");
          })).join("|");
  var tok_names = Belt_MapInt.fromArray(Belt_MutableMapInt.toArray(mut_tok_names));
  var re = new RegExp(re_str);
  while(lexbuf[/* pos */1][/* character */1] < lexbuf[/* buf */0].length) {
    var tok = get_next_tok(tok_names, re, lexbuf);
    if (tok[/* start */1] !== lexbuf[/* pos */1][/* character */1]) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            /* tuple */[
              "Lex.ml",
              94,
              6
            ]
          ];
    }
    lexbuf[/* pos */1] = /* record */[
      /* line */0,
      /* character */tok[/* finish */2]
    ];
    result.push(tok);
  };
  return result;
}

function lex(lexer, input) {
  try {
    return /* Ok */Block.__(0, [lex$prime(lexer, input)]);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === LexError) {
      return /* Error */Block.__(1, [exn[1]]);
    } else {
      throw exn;
    }
  }
}

exports.lex = lex;
/* No side effect */
