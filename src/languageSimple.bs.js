// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';


var str = "\n== abstract syntax ==\n\ntm :=\n  | var(var)\n  | annot(tm; ty)\n  | ite(t1: tm; t2: tm; t3: tm)\n  | app(t1: tm; t2: tm)\n  | val(val)\n  | binary-op(binary-op)\n\nbinary-op :=\n  | or(t1: tm; t2: tm)\n  | xor(t1: tm; t2: tm)\n  | and(t1: tm; t2: tm)\n\nval :=\n  | true()\n  | false()\n  | lam(val. tm)\n\nty :=\n  | bool()\n  | arr(ty; ty)\n\n== statics ==\n\n// TODO:\n// * should we use concrete syntax?\n// * how to show var separate from context?\n// * how to separate hypotheses?\n// * should we make var rule explicit instead of implicit?\n\n----------------------- (bool intro 1)\nctx >> true() => bool()\n\n------------------------ (bool intro 2)\nctx >> false() => bool()\n\n  ctx >> v => ty\n------------------- (val)\nctx >> val(v) => ty\n\n      ctx >> tm <= ty\n-------------------------- (annot)\nctx >> annot(tm; ty) => ty\n\nctx >> t1 <= bool()  ctx >> t2 <= ty  ctx >> t3 <= ty\n----------------------------------------------------- (bool elim)\n           ctx >> ite(t1; t2; t3) <= ty\n\n    ctx, x : ty1 >> tm <= ty2\n---------------------------------- (lam intro)\nctx >> lam(x. tm) <= arr(ty1; ty2)\n\nctx >> tm1 => arr(ty1; ty2)  ctx >> tm2 <= ty1\n---------------------------------------------- (lam elim)\n        ctx >> app(tm1; tm2) => ty2\n\n// important: this rule must go last or else it will subsume all others\nctx >> tm => ty\n--------------- (switch)\nctx >> tm <= ty\n\n== dynamics ==\n\n// [[_]] : tm -> core(val)\n\n[[ value(v)        ]] = v\n[[ annot(tm; ty)   ]] = [[ tm ]]\n[[ ite(t1; t2; t3) ]] = case([[ t1 ]]; true() -> [[ t2 ]]; false() -> [[ t3 ]])\n[[ app(fun; arg)   ]] = app([[ fun ]]; [[ arg ]])\n\n== dynamics ==\n";

exports.str = str;
/* No side effect */
