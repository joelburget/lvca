// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Util = require("./Util.bs.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function enscope(binders, param) {
  return /* Scope */[
          Pervasives.$at(param[0], binders),
          param[1]
        ];
}

var NoMatch = Caml_exceptions.create("Bidirectional.NoMatch");

function match_schema_vars$prime(t1, t2) {
  switch (t1.tag | 0) {
    case 0 : 
        if (t2.tag) {
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "Bidirectional.ml",
                  19,
                  35
                ]
              ];
        } else {
          var args2 = t2[1];
          var args1 = t1[1];
          if (t1[0] === t2[0] && Belt_List.length(args1) === Belt_List.length(args2)) {
            return Util.unions(Belt_List.zipBy(args1, args2, match_schema_vars_scope));
          } else {
            throw NoMatch;
          }
        }
    case 2 : 
        return Belt_MapString.fromArray(/* array */[/* tuple */[
                      t1[0],
                      /* Scope */[
                        /* [] */0,
                        t2
                      ]
                    ]]);
    default:
      throw [
            Caml_builtin_exceptions.match_failure,
            /* tuple */[
              "Bidirectional.ml",
              19,
              35
            ]
          ];
  }
}

function match_schema_vars_scope(param, param$1) {
  var names1 = param[0];
  if (Belt_List.length(names1) === Belt_List.length(param$1[0])) {
    return Belt_MapString.map(match_schema_vars$prime(param[1], param$1[1]), (function (param) {
                  return enscope(names1, param);
                }));
  } else {
    throw NoMatch;
  }
}

function match_schema_vars(t1, t2) {
  try {
    return Caml_option.some(match_schema_vars$prime(t1, t2));
  }
  catch (exn){
    if (exn === NoMatch) {
      return undefined;
    } else {
      throw exn;
    }
  }
}

function open_scope(args, param) {
  if (Belt_List.length(args) !== Belt_List.length(param[0])) {
    return undefined;
  } else {
    var open$prime = function (offset, tm) {
      switch (tm.tag | 0) {
        case 0 : 
            var tag = tm[0];
            return Belt_Option.map(Util.sequence_list_option(Belt_List.map(tm[1], (function (param) {
                                  var binders = param[0];
                                  return Belt_Option.map(open$prime(offset + Belt_List.length(binders) | 0, param[1]), (function (subtm$prime) {
                                                return /* Scope */[
                                                        binders,
                                                        subtm$prime
                                                      ];
                                              }));
                                }))), (function (subtms$prime) {
                          return /* Term */Block.__(0, [
                                    tag,
                                    subtms$prime
                                  ]);
                        }));
        case 1 : 
            var i = tm[0];
            if (i >= offset) {
              return Belt_List.get(args, i - offset | 0);
            } else {
              return tm;
            }
        case 3 : 
            return Belt_Option.map(Util.sequence_list_option(Belt_List.map(tm[0], (function (param) {
                                  return open$prime(offset, param);
                                }))), (function (tms$prime) {
                          return /* Sequence */Block.__(3, [tms$prime]);
                        }));
        case 2 : 
        case 4 : 
            return tm;
        
      }
    };
    return open$prime(0, param[1]);
  }
}

function instantiate(env, tm) {
  switch (tm.tag | 0) {
    case 0 : 
        var tag = tm[0];
        return Belt_Option.map(Util.sequence_list_option(Belt_List.map(tm[1], (function (param) {
                              var binders = param[0];
                              return Belt_Option.map(instantiate(Belt_MapString.removeMany(env, Belt_List.toArray(binders)), param[1]), (function (body$prime) {
                                            return /* Scope */[
                                                    binders,
                                                    body$prime
                                                  ];
                                          }));
                            }))), (function (subtms$prime) {
                      return /* Term */Block.__(0, [
                                tag,
                                subtms$prime
                              ]);
                    }));
    case 2 : 
        var match = Belt_MapString.get(env, tm[0]);
        if (match !== undefined) {
          var sc = match;
          return open_scope(Belt_List.map(sc[0], (function (name) {
                            return /* Free */Block.__(2, [name]);
                          })), sc);
        } else {
          return undefined;
        }
    case 3 : 
        return Belt_Option.map(Util.sequence_list_option(Belt_List.map(tm[0], (function (param) {
                              return instantiate(env, param);
                            }))), (function (tms$prime) {
                      return /* Sequence */Block.__(3, [tms$prime]);
                    }));
    case 1 : 
    case 4 : 
        return tm;
    
  }
}

var BadMerge = Caml_exceptions.create("Bidirectional.BadMerge");

function safe_union(m1, m2) {
  return Belt_MapString.merge(m1, m2, (function (param, mv1, mv2) {
                if (mv1 !== undefined) {
                  var v1 = Caml_option.valFromOption(mv1);
                  if (mv2 !== undefined && !Caml_obj.caml_equal(v1, Caml_option.valFromOption(mv2))) {
                    throw BadMerge;
                  } else {
                    return Caml_option.some(v1);
                  }
                } else if (mv2 !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(mv2));
                } else {
                  throw BadMerge;
                }
              }));
}

var CheckError = Caml_exceptions.create("Bidirectional.CheckError");

function update_ctx(ctx_state, learned_tys) {
  var ctx = ctx_state[0];
  var do_assignment = function (param) {
    var v = param[1];
    var k = param[0];
    var match = Belt_MapString.get(ctx, k);
    if (match !== undefined) {
      if (Caml_obj.caml_notequal(v, match)) {
        throw BadMerge;
      } else {
        return 0;
      }
    } else {
      ctx_state[0] = Belt_MapString.set(ctx, k, v);
      return /* () */0;
    }
  };
  return List.iter(do_assignment, Belt_MapString.toList(learned_tys));
}

function get_or_raise(msg, param) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  } else {
    throw [
          CheckError,
          msg
        ];
  }
}

function check(env, param) {
  var ty = param[1];
  var tm = param[0];
  var match_rule = function (param) {
    var match = param[/* conclusion */2][1];
    if (match.tag) {
      var match$1 = match[0];
      var match1 = match_schema_vars(match$1[/* tm */0], tm);
      var match2 = match_schema_vars(match$1[/* ty */1], ty);
      if (match1 !== undefined && match2 !== undefined) {
        return /* tuple */[
                param[/* hypotheses */0],
                Caml_option.valFromOption(match1),
                Caml_option.valFromOption(match2)
              ];
      } else {
        return undefined;
      }
    }
    
  };
  var match = get_or_raise("1", Util.first_by(env[/* rules */0], match_rule));
  var ctx_state = /* record */[/* contents */Belt_MapString.empty];
  var assignments = Util.union(match[1], match[2]);
  return List.iter((function (param) {
                return check_hyp(ctx_state, assignments, env, param);
              }), match[0]);
}

function infer(env, tm) {
  var match_rule = function (param) {
    var match = param[/* conclusion */2][1];
    var hypotheses = param[/* hypotheses */0];
    if (match.tag) {
      return undefined;
    } else {
      var match$1 = match[0];
      var rule_ty = match$1[/* ty */1];
      return Belt_Option.map(match_schema_vars(match$1[/* tm */0], tm), (function (assignments) {
                    return /* tuple */[
                            hypotheses,
                            assignments,
                            rule_ty
                          ];
                  }));
    }
  };
  var match = get_or_raise("2", Util.first_by(env[/* rules */0], match_rule));
  var assignments = match[1];
  var ctx_state = /* record */[/* contents */Belt_MapString.empty];
  List.iter((function (param) {
          return check_hyp(ctx_state, assignments, env, param);
        }), match[0]);
  return get_or_raise("3", instantiate(ctx_state[0], match[2]));
}

function check_hyp(ctx_state, assignments, env, param) {
  var rule = param[1];
  if (rule.tag) {
    var match = rule[0];
    var tm = get_or_raise("4", instantiate(assignments, match[/* tm */0]));
    var ty = get_or_raise("5", instantiate(assignments, match[/* ty */1]));
    return check(env, /* Typing */[
                tm,
                ty
              ]);
  } else {
    var match$1 = rule[0];
    var tm$1 = get_or_raise("6", instantiate(assignments, match$1[/* tm */0]));
    var ty$1 = infer(env, tm$1);
    var learned_tys = get_or_raise("7", match_schema_vars(match$1[/* ty */1], ty$1));
    return update_ctx(ctx_state, learned_tys);
  }
}

var M = 0;

var BL = 0;

var BO = 0;

exports.M = M;
exports.BL = BL;
exports.BO = BO;
exports.enscope = enscope;
exports.NoMatch = NoMatch;
exports.match_schema_vars$prime = match_schema_vars$prime;
exports.match_schema_vars_scope = match_schema_vars_scope;
exports.match_schema_vars = match_schema_vars;
exports.open_scope = open_scope;
exports.instantiate = instantiate;
exports.BadMerge = BadMerge;
exports.safe_union = safe_union;
exports.CheckError = CheckError;
exports.update_ctx = update_ctx;
exports.get_or_raise = get_or_raise;
exports.check = check;
exports.infer = infer;
exports.check_hyp = check_hyp;
/* No side effect */
