// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");

function intersperse(list, el) {
  if (list) {
    var match = list[1];
    if (match) {
      return /* :: */[
              list[0],
              /* :: */[
                el,
                intersperse(/* :: */[
                      match[0],
                      match[1]
                    ], el)
              ]
            ];
    } else {
      return list;
    }
  } else {
    return list;
  }
}

function intersperse_after(list, el) {
  if (list) {
    var match = list[1];
    var list_el = list[0];
    if (match) {
      return /* :: */[
              list_el,
              /* :: */[
                el,
                intersperse_after(/* :: */[
                      match[0],
                      match[1]
                    ], el)
              ]
            ];
    } else {
      return /* :: */[
              list_el,
              /* :: */[
                el,
                /* [] */0
              ]
            ];
    }
  } else {
    return /* [] */0;
  }
}

function get_first(f, _lst) {
  while(true) {
    var lst = _lst;
    if (lst) {
      var some_b = Curry._1(f, lst[0]);
      if (some_b !== undefined) {
        return some_b;
      } else {
        _lst = lst[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function traverse_list_result(lst) {
  if (lst) {
    var match = lst[0];
    if (match.tag) {
      return /* Error */Block.__(1, [match[0]]);
    } else {
      var match$1 = traverse_list_result(lst[1]);
      if (match$1.tag) {
        return /* Error */Block.__(1, [match$1[0]]);
      } else {
        return /* Ok */Block.__(0, [/* :: */[
                    match[0],
                    match$1[0]
                  ]]);
      }
    }
  } else {
    return /* Ok */Block.__(0, [/* [] */0]);
  }
}

function union(m1, m2) {
  return Belt_MapString.merge(m1, m2, (function (_k, v1, v2) {
                if (v2 !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(v2));
                } else if (v1 !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(v1));
                } else {
                  return undefined;
                }
              }));
}

function fold_right(f, lst, b) {
  if (lst) {
    return Curry._1(f, /* tuple */[
                lst[0],
                fold_right(f, lst[1], b)
              ]);
  } else {
    return b;
  }
}

exports.intersperse = intersperse;
exports.intersperse_after = intersperse_after;
exports.get_first = get_first;
exports.traverse_list_result = traverse_list_result;
exports.union = union;
exports.fold_right = fold_right;
/* No side effect */
