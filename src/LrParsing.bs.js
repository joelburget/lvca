// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Bitstring = require("./Bitstring.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_SetInt = require("bs-platform/lib/js/belt_SetInt.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Belt_MutableMapInt = require("bs-platform/lib/js/belt_MutableMapInt.js");
var Belt_MutableSetInt = require("bs-platform/lib/js/belt_MutableSetInt.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function view_item(item) {
  return /* record */[
          /* production_num */item & 16777215,
          /* position */((item & -16777216) >>> 24)
        ];
}

function mk_item$prime(production_num, position) {
  return (position << 24) | production_num;
}

function mk_item(param) {
  return mk_item$prime(param[/* production_num */0], param[/* position */1]);
}

function Lr0(G) {
  var production_map = Belt_MutableMapInt.make(/* () */0);
  var production_nonterminal_map = Belt_MutableMapInt.make(/* () */0);
  var nonterminal_production_map = Belt_MutableMapInt.make(/* () */0);
  var production_cnt = /* record */[/* contents */0];
  Belt_MapInt.forEach(G[/* grammar */0], (function (nt_num, param) {
          Belt_MutableMapInt.set(nonterminal_production_map, nt_num, Belt_MutableSetInt.make(/* () */0));
          return Belt_List.forEach(param[/* productions */0], (function (production) {
                        var production_num = production_cnt[0];
                        production_cnt[0] = production_num + 1 | 0;
                        Belt_MutableMapInt.set(production_map, production_num, production);
                        Belt_MutableMapInt.set(production_nonterminal_map, production_num, nt_num);
                        var prod_set = Belt_MutableMapInt.getExn(nonterminal_production_map, nt_num);
                        return Belt_MutableSetInt.add(prod_set, production_num);
                      }));
        }));
  var number_of_nonterminals = Belt_MapInt.size(G[/* grammar */0]);
  var get_nonterminal_num = function (param) {
    return Belt_MutableMapInt.getExn(production_nonterminal_map, param);
  };
  var get_nonterminal = function (pn) {
    return Belt_MapInt.getExn(G[/* grammar */0], Belt_MutableMapInt.getExn(production_nonterminal_map, pn));
  };
  var closure = function (initial_items) {
    var added = Bitstring.alloc(number_of_nonterminals, false);
    var nonkernel_items = Belt_MutableSetInt.make(/* () */0);
    var nt_stack = Belt_MutableSetInt.make(/* () */0);
    Belt_SetInt.forEach(initial_items, (function (item) {
            var match = view_item(item);
            var production = Belt_MutableMapInt.getExn(production_map, match[/* production_num */0]);
            var match$1 = Belt_List.get(production, match[/* position */1]);
            if (match$1 !== undefined) {
              var match$2 = match$1;
              if (match$2.tag) {
                return Belt_MutableSetInt.add(nt_stack, match$2[0]);
              } else {
                return /* () */0;
              }
            } else {
              return /* () */0;
            }
          }));
    while(!Belt_MutableSetInt.isEmpty(nt_stack)) {
      var match = Belt_MutableSetInt.minimum(nt_stack);
      var nonterminal_num = match !== undefined ? match : Pervasives.failwith("invariant violation: the set is not empty!");
      Belt_MutableSetInt.remove(nt_stack, nonterminal_num);
      if (!Bitstring.getExn(added, nonterminal_num)) {
        Bitstring.setExn(added, nonterminal_num, true);
        var production_set = Belt_MutableMapInt.getExn(nonterminal_production_map, nonterminal_num);
        Belt_MutableSetInt.forEach(production_set, (function (production_num) {
                return Belt_MutableSetInt.add(nonkernel_items, mk_item$prime(production_num, 0));
              }));
        var match$1 = Belt_MapInt.getExn(G[/* grammar */0], nonterminal_num);
        Belt_List.forEach(match$1[/* productions */0], (function (production) {
                if (production) {
                  var match = production[0];
                  if (match.tag) {
                    return Belt_MutableSetInt.add(nt_stack, match[0]);
                  } else {
                    return /* () */0;
                  }
                } else {
                  return Pervasives.failwith("Empty production");
                }
              }));
      }
      
    };
    return /* record */[
            /* kernel_items */initial_items,
            /* nonkernel_items */Belt_SetInt.fromArray(Belt_MutableSetInt.toArray(nonkernel_items))
          ];
  };
  var simplify_config_set = function (param) {
    return Belt_SetInt.union(param[/* kernel_items */0], param[/* nonkernel_items */1]);
  };
  var closure$prime = function (items) {
    return simplify_config_set(closure(items));
  };
  var goto_kernel = function (item_set, nt) {
    var result = Belt_MutableSetInt.make(/* () */0);
    Belt_SetInt.forEach(item_set, (function (item) {
            var match = view_item(item);
            var position = match[/* position */1];
            var production_num = match[/* production_num */0];
            var production = Belt_MutableMapInt.getExn(production_map, production_num);
            var match$1 = Belt_List.get(production, position);
            if (match$1 !== undefined) {
              var match$2 = match$1;
              if (match$2.tag || nt !== match$2[0]) {
                return /* () */0;
              } else {
                return Belt_MutableSetInt.add(result, mk_item$prime(production_num, position + 1 | 0));
              }
            } else {
              return /* () */0;
            }
          }));
    return Belt_SetInt.fromArray(Belt_MutableSetInt.toArray(result));
  };
  var $$goto = function (item_set, nt) {
    return closure(goto_kernel(item_set, nt));
  };
  var augmented_start = Belt_SetInt.fromArray(/* array */[mk_item(/* record */[
              /* production_num */0,
              /* position */0
            ])]);
  var c = /* record */[/* contents : :: */[
      simplify_config_set(closure(augmented_start)),
      /* [] */0
    ]];
  var $$continue = /* record */[/* contents */true];
  while($$continue[0]) {
    $$continue[0] = false;
    Belt_List.forEach(c[0], (function (i) {
            return Belt_MapInt.forEach(G[/* grammar */0], (function (x, param) {
                          var goto_i_x = simplify_config_set(closure(goto_kernel(i, x)));
                          if (!Belt_SetInt.isEmpty(goto_i_x) && !Belt_List.has(c[0], goto_i_x, Caml_obj.caml_equal)) {
                            c[0] = /* :: */[
                              goto_i_x,
                              c[0]
                            ];
                            $$continue[0] = true;
                            return /* () */0;
                          } else {
                            return 0;
                          }
                        }));
          }));
  };
  var items = c[0];
  var items$prime = Belt_MapInt.fromArray(Belt_List.toArray(Belt_List.mapWithIndex(items, (function (i, item_set) {
                  return /* tuple */[
                          i,
                          item_set
                        ];
                }))));
  var state_to_item_set = function (param) {
    return Belt_MapInt.getExn(items$prime, param);
  };
  var item_set_to_state = function (item_set) {
    return Belt_Option.getExn(Belt_MapInt.findFirstBy(items$prime, (function (k, item_set$prime) {
                        return Caml_obj.caml_equal(item_set$prime, item_set);
                      })))[0];
  };
  var action_table = function (state, terminal) {
    var shift_action = Pervasives.failwith("TODO");
    var reduce_action = Pervasives.failwith("TODO");
    var accept_action = Pervasives.failwith("TODO");
    var exit = 0;
    if (shift_action !== undefined) {
      if (reduce_action !== undefined || accept_action !== undefined) {
        exit = 1;
      } else {
        return Caml_option.valFromOption(shift_action);
      }
    } else if (reduce_action !== undefined) {
      if (accept_action !== undefined) {
        exit = 1;
      } else {
        return Caml_option.valFromOption(reduce_action);
      }
    } else if (accept_action !== undefined) {
      return Caml_option.valFromOption(accept_action);
    } else {
      return /* Error */1;
    }
    if (exit === 1) {
      throw [
            Caml_builtin_exceptions.match_failure,
            /* tuple */[
              "LrParsing.ml",
              255,
              8
            ]
          ];
    }
    
  };
  var goto_table = function (state, nt) {
    var item_set = Belt_MapInt.getExn(items$prime, state);
    return item_set_to_state(simplify_config_set(closure(goto_kernel(item_set, nt))));
  };
  var slr_tables = /* tuple */[
    action_table,
    goto_table
  ];
  return /* module */[
          /* production_map */production_map,
          /* production_nonterminal_map */production_nonterminal_map,
          /* nonterminal_production_map */nonterminal_production_map,
          /* production_cnt */production_cnt,
          /* number_of_nonterminals */number_of_nonterminals,
          /* get_nonterminal_num */get_nonterminal_num,
          /* get_nonterminal */get_nonterminal,
          /* closure */closure,
          /* simplify_config_set */simplify_config_set,
          /* closure' */closure$prime,
          /* goto_kernel */goto_kernel,
          /* goto */$$goto,
          /* items */items,
          /* items' */items$prime,
          /* state_to_item_set */state_to_item_set,
          /* item_set_to_state */item_set_to_state,
          /* slr_tables */slr_tables
        ];
}

function lalr_tables(grammar) {
  Pervasives.failwith("TODO");
  Pervasives.failwith("TODO");
  var action_table = Pervasives.failwith("TODO");
  var goto_table = Pervasives.failwith("TODO");
  return /* tuple */[
          action_table,
          goto_table
        ];
}

var ParseFinished = Caml_exceptions.create("LrParsing.ParseFinished");

var ParseFailed = Caml_exceptions.create("LrParsing.ParseFailed");

var PopFailed = Caml_exceptions.create("LrParsing.PopFailed");

function pop_exn(arr) {
  var match = arr.pop();
  if (match !== undefined) {
    return match;
  } else {
    throw PopFailed;
  }
}

function parse(param, toks) {
  var goto_table = param[1];
  var action_table = param[0];
  var stack = /* :: */[
    0,
    /* [] */0
  ];
  try {
    while(true) {
      var match = stack;
      if (match) {
        var a = /* record */[/* contents */pop_exn(toks)];
        var a$prime = Curry._1(Pervasives.failwith("TODO"), a);
        var match$1 = Curry._2(action_table, match[0], a$prime);
        if (typeof match$1 === "number") {
          if (match$1 === 0) {
            throw ParseFinished;
          } else {
            throw [
                  ParseFailed,
                  Pervasives.failwith("TODO")
                ];
          }
        } else if (match$1.tag) {
          var match$2 = stack;
          if (match$2) {
            stack = /* :: */[
              Curry._2(goto_table, match$2[0], a$prime),
              match$2[1]
            ];
          } else {
            Pervasives.failwith("invariant violation: reduction with empty stack");
          }
        } else {
          stack = /* :: */[
            match$1[0],
            stack
          ];
          a[0] = pop_exn(toks);
        }
      } else {
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "LrParsing.ml",
                309,
                12
              ]
            ];
      }
    };
    return Pervasives.failwith("can't make it here");
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn === ParseFinished) {
      return Pervasives.failwith("TODO");
    } else if (exn[0] === ParseFailed) {
      return /* Error */Block.__(1, [exn[1]]);
    } else {
      throw exn;
    }
  }
}

var A = 0;

var L = 0;

var M = 0;

var MM = 0;

var SI = 0;

var SS = 0;

var MSI = 0;

var Result = 0;

exports.A = A;
exports.L = L;
exports.M = M;
exports.MM = MM;
exports.SI = SI;
exports.SS = SS;
exports.MSI = MSI;
exports.Result = Result;
exports.view_item = view_item;
exports.mk_item$prime = mk_item$prime;
exports.mk_item = mk_item;
exports.Lr0 = Lr0;
exports.lalr_tables = lalr_tables;
exports.ParseFinished = ParseFinished;
exports.ParseFailed = ParseFailed;
exports.PopFailed = PopFailed;
exports.pop_exn = pop_exn;
exports.parse = parse;
/* No side effect */
