// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Util = require("./Util.bs.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Bigint = require("bs-zarith/src/Bigint.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var LrParsing = require("./LrParsing.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Belt_SetInt = require("bs-platform/lib/js/belt_SetInt.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Belt_MutableMapInt = require("bs-platform/lib/js/belt_MutableMapInt.js");
var Belt_MutableSetInt = require("bs-platform/lib/js/belt_MutableSetInt.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var AA = Util.ArrayApplicative(/* module */[]);

function equivalent(t1, t2) {
  if (Caml_obj.caml_equal(t1[/* sort */0], t2[/* sort */0]) && Caml_obj.caml_equal(t1[/* node_type */1], t2[/* node_type */1])) {
    return Belt_Array.every(Belt_Array.zipBy(t1[/* children */4], t2[/* children */4], equivalent$prime), (function (b) {
                  return b;
                }));
  } else {
    return false;
  }
}

function equivalent$prime(child1, child2) {
  switch (child1.tag | 0) {
    case 0 : 
        switch (child2.tag | 0) {
          case 0 : 
              return Caml_obj.caml_equal(child1[0], child2[0]);
          case 1 : 
          case 2 : 
              return false;
          
        }
    case 1 : 
        switch (child2.tag | 0) {
          case 1 : 
              return equivalent(child1[0], child2[0]);
          case 0 : 
          case 2 : 
              return false;
          
        }
    case 2 : 
        switch (child2.tag | 0) {
          case 0 : 
          case 1 : 
              return false;
          case 2 : 
              return child1[0] === child2[0];
          
        }
    
  }
}

function find_operator_match(matches, opname) {
  var maybe_match = Util.find((function (param) {
          var term_pattern = param[0][/* term_pattern */1];
          if (term_pattern.tag) {
            return false;
          } else {
            return term_pattern[0] === opname;
          }
        }), Belt_List.flatten(matches));
  if (maybe_match !== undefined) {
    return maybe_match;
  } else {
    return Pervasives.failwith("TODO: default match");
  }
}

var BadSortTerm = Caml_exceptions.create("ConcreteSyntax.BadSortTerm");

var BadRules = Caml_exceptions.create("ConcreteSyntax.BadRules");

var CantEmitTokenRegex = Caml_exceptions.create("ConcreteSyntax.CantEmitTokenRegex");

function regex_is_literal(param) {
  if (param) {
    var match = param[0];
    if (match.tag || param[1]) {
      return undefined;
    } else {
      return match[0];
    }
  }
  
}

function regex_piece_to_string(param) {
  switch (param.tag | 0) {
    case 0 : 
        return param[0].replace((/\//g), "\\/").replace((/\+/g), "\\+").replace((/\*/g), "\\*").replace((/\?/g), "\\?").replace((/\-/g), "\\-").replace((/\(/g), "\\(").replace((/\)/g), "\\)");
    case 1 : 
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "ConcreteSyntax.ml",
                134,
                56
              ]
            ];
    case 2 : 
        return "[" + (param[0] + "]");
    case 3 : 
        return regex_piece_to_string(param[0]) + "*";
    case 4 : 
        return regex_piece_to_string(param[0]) + "+";
    case 5 : 
        return regex_piece_to_string(param[0]) + "?";
    
  }
}

function regex_to_string(re_parts) {
  return $$String.concat("", List.map(regex_piece_to_string, re_parts));
}

var CheckValidExn = Caml_exceptions.create("ConcreteSyntax.CheckValidExn");

function accumulate_tokens(param, param$1) {
  var seen_toks$prime = param$1[/* captured_tokens */0];
  var seen_toks = param[/* captured_tokens */0];
  var isect = Belt_SetInt.intersect(seen_toks, seen_toks$prime);
  return /* record */[
          /* captured_tokens */Belt_SetInt.diff(Belt_SetInt.union(seen_toks, seen_toks$prime), isect),
          /* repeated_tokens */Belt_SetInt.union(isect, Belt_SetInt.union(param[/* repeated_tokens */1], param$1[/* repeated_tokens */1]))
        ];
}

var empty_tokens_info = /* record */[
  /* captured_tokens */Belt_SetInt.empty,
  /* repeated_tokens */Belt_SetInt.empty
];

function scope_token_usage(param) {
  return Belt_List.reduce(/* :: */[
              param[1],
              param[0]
            ], empty_tokens_info, (function (accum, tok) {
                return accumulate_tokens(accum, /* record */[
                            /* captured_tokens */Belt_SetInt.fromArray(/* array */[tok]),
                            /* repeated_tokens */Belt_SetInt.empty
                          ]);
              }));
}

function token_usage(param) {
  if (param.tag) {
    return /* record */[
            /* captured_tokens */Belt_SetInt.fromArray(/* array */[param[0]]),
            /* repeated_tokens */Belt_SetInt.empty
          ];
  } else {
    return Belt_List.reduce(param[1], empty_tokens_info, (function (accum, scope_pat) {
                  return accumulate_tokens(accum, scope_token_usage(scope_pat));
                }));
  }
}

function check_operator_match_validity(token_list, term_pat) {
  var numbered_toks = Belt_MutableMapInt.fromArray(Belt_Array.mapWithIndex(Belt_List.toArray(token_list), (function (i, tok) {
              return /* tuple */[
                      i,
                      tok
                    ];
            })));
  var match = token_usage(term_pat);
  var non_existent_tokens = Belt_MutableSetInt.make(/* () */0);
  Belt_SetInt.forEach(match[/* captured_tokens */0], (function (tok_num) {
          if (Belt_MutableMapInt.has(numbered_toks, tok_num)) {
            return Belt_MutableMapInt.remove(numbered_toks, tok_num);
          } else {
            return Belt_MutableSetInt.add(non_existent_tokens, tok_num);
          }
        }));
  return /* tuple */[
          non_existent_tokens,
          match[/* repeated_tokens */1],
          Belt_MutableMapInt.toList(numbered_toks)
        ];
}

function check_description_validity(param) {
  var terminal_rules = param[/* terminal_rules */0];
  try {
    Belt_MapString.map(param[/* sort_rules */1], (function (param) {
            var operator_maches = Belt_List.flatten(param[0][/* operator_rules */1]);
            Belt_List.map(operator_maches, (function (param) {
                    var match = param[0];
                    var match$1 = check_operator_match_validity(match[/* tokens */0], match[/* term_pattern */1]);
                    var duplicate_captures = match$1[1];
                    var non_existent_tokens = match$1[0];
                    if (!Belt_SetInt.isEmpty(duplicate_captures)) {
                      var tok_names = Belt_Array.map(Belt_SetInt.toArray(duplicate_captures), Printf.sprintf(/* Format */[
                                  /* Char_literal */Block.__(12, [
                                      /* "$" */36,
                                      /* Scan_get_counter */Block.__(21, [
                                          /* Char_counter */1,
                                          /* End_of_format */0
                                        ])
                                    ]),
                                  "$%n"
                                ])).join(", ");
                      throw [
                            CheckValidExn,
                            /* InvalidGrammar */["tokens captured more than once: " + tok_names]
                          ];
                    }
                    if (!Belt_MutableSetInt.isEmpty(non_existent_tokens)) {
                      var tok_names$1 = Belt_Array.map(Belt_MutableSetInt.toArray(non_existent_tokens), Printf.sprintf(/* Format */[
                                  /* Char_literal */Block.__(12, [
                                      /* "$" */36,
                                      /* Scan_get_counter */Block.__(21, [
                                          /* Char_counter */1,
                                          /* End_of_format */0
                                        ])
                                    ]),
                                  "$%n"
                                ])).join(", ");
                      throw [
                            CheckValidExn,
                            /* InvalidGrammar */["non-existent tokens mentioned: " + tok_names$1]
                          ];
                    }
                    return Belt_List.map(match$1[2], (function (param) {
                                  var tok = param[1];
                                  if (typeof tok === "number") {
                                    return /* () */0;
                                  } else if (tok.tag) {
                                    throw [
                                          CheckValidExn,
                                          /* InvalidGrammar */["uncaptured nonterminal: " + tok[0]]
                                        ];
                                  } else {
                                    var nt_name = tok[0];
                                    var match = Belt_MapString.get(terminal_rules, nt_name);
                                    if (match !== undefined) {
                                      if (Util.is_some(regex_is_literal(match))) {
                                        return /* () */0;
                                      } else {
                                        throw [
                                              CheckValidExn,
                                              /* InvalidGrammar */["Uncaptured regex which is not a string literal"]
                                            ];
                                      }
                                    } else {
                                      throw [
                                            CheckValidExn,
                                            /* InvalidGrammar */["Named terminal " + (nt_name + " does not exist")]
                                          ];
                                    }
                                  }
                                }));
                  }));
            return /* () */0;
          }));
    return undefined;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === CheckValidExn) {
      return exn[1];
    } else {
      throw exn;
    }
  }
}

function mk_tree(sort, node_type, children) {
  return /* record */[
          /* sort */sort,
          /* node_type */node_type,
          /* leading_trivia */"",
          /* trailing_trivia */"",
          /* children */children
        ];
}

function mk_terminal_capture(content) {
  return /* TerminalCapture */Block.__(0, [/* record */[
              /* content */content,
              /* leading_trivia */"",
              /* trailing_trivia */""
            ]]);
}

function of_ast(lang, rules, current_sort, tm) {
  var terminal_rules = rules[/* terminal_rules */0];
  var sorts = lang[0];
  var exit = 0;
  var sort_name = current_sort[0];
  var exit$1 = 0;
  switch (tm.tag | 0) {
    case 0 : 
        var scopes = tm[1];
        var op_name = tm[0];
        var match = Util.get_option$prime("of_ast: failed to get sort " + sort_name)(Belt_MapString.get(rules[/* sort_rules */1], sort_name));
        var match$1 = find_operator_match(match[0][/* operator_rules */1], op_name);
        var match$2 = match$1[0];
        var term_pattern = match$2[/* term_pattern */1];
        var find_subtm$prime = function (ix) {
          if (term_pattern.tag) {
            return /* FoundCapture */1;
          } else {
            var param = ix;
            var param$1 = scopes;
            var param$2 = term_pattern[1];
            var _slot_num = 0;
            var token_ix = param;
            var _scopes = param$1;
            var _term_pattern = param$2;
            while(true) {
              var term_pattern$1 = _term_pattern;
              var scopes$1 = _scopes;
              var slot_num = _slot_num;
              if (term_pattern$1) {
                if (scopes$1) {
                  var match = term_pattern$1[0];
                  var match$1 = scopes$1[0];
                  var binder_matches = Util.find((function (param) {
                          return param[1] === token_ix;
                        }), Belt_List.zip(match$1[0], match[0]));
                  if (binder_matches !== undefined) {
                    return /* FoundBinder */Block.__(1, [binder_matches[0]]);
                  } else if (token_ix === match[1]) {
                    return /* FoundTerm */Block.__(0, [
                              slot_num,
                              match$1[1]
                            ]);
                  } else {
                    _term_pattern = term_pattern$1[1];
                    _scopes = scopes$1[1];
                    _slot_num = slot_num + 1 | 0;
                    continue ;
                  }
                } else {
                  return Pervasives.failwith("invariant violation: mismatched scopes / term patterns");
                }
              } else {
                return /* NotFound */0;
              }
            };
          }
        };
        var children = Belt_Array.map(Belt_List.toArray(Belt_List.keep(Belt_List.mapWithIndex(match$2[/* tokens */0], (function (token_ix, token) {
                            return /* tuple */[
                                    token_ix,
                                    token
                                  ];
                          })), (function (param) {
                        if (typeof param[1] === "number") {
                          return false;
                        } else {
                          return true;
                        }
                      }))), (function (param) {
                var token = param[1];
                var token_ix$prime = param[0] + 1 | 0;
                var match = find_subtm$prime(token_ix$prime);
                var exit = 0;
                if (typeof match === "number") {
                  if (match === 0) {
                    if (typeof token === "number") {
                      exit = 1;
                    } else if (token.tag) {
                      throw [
                            BadRules,
                            "subterm not found, nonterminal name: " + token[0]
                          ];
                    } else {
                      var name = token[0];
                      var terminal_rule = Util.get_option$prime("of_ast: failed to get terminal rule " + name)(Belt_MapString.get(terminal_rules, name));
                      var match$1 = regex_is_literal(terminal_rule);
                      if (match$1 !== undefined) {
                        return mk_terminal_capture(match$1);
                      } else {
                        throw [
                              CantEmitTokenRegex,
                              name,
                              terminal_rule
                            ];
                      }
                    }
                  } else if (typeof token === "number") {
                    exit = 1;
                  } else if (token.tag) {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          /* tuple */[
                            "ConcreteSyntax.ml",
                            334,
                            11
                          ]
                        ];
                  } else {
                    throw [
                          BadRules,
                          "capture found, terminal name: " + token[0]
                        ];
                  }
                } else if (match.tag) {
                  var binder_name = match[0];
                  if (typeof token === "number") {
                    exit = 1;
                  } else if (token.tag) {
                    throw [
                          BadRules,
                          "binder (" + (binder_name + (") found, nonterminal name: " + token[0]))
                        ];
                  } else {
                    return mk_terminal_capture(binder_name);
                  }
                } else {
                  var subtm = match[1];
                  var tm_ix = match[0];
                  if (typeof token === "number") {
                    exit = 1;
                  } else if (token.tag) {
                    var sort = token[0];
                    var match$2 = Util.get_option$prime("of_ast: failed to get sort" + sort)(Belt_MapString.get(sorts, sort));
                    var some_operator = Util.find((function (param) {
                            return param[0] === op_name;
                          }), match$2[1]);
                    var valences;
                    if (some_operator !== undefined) {
                      valences = some_operator[1][1];
                    } else {
                      throw [
                            Caml_builtin_exceptions.assert_failure,
                            /* tuple */[
                              "ConcreteSyntax.ml",
                              350,
                              23
                            ]
                          ];
                    }
                    var valence = Util.get_option$prime("of_ast: failed to get term " + String(tm_ix))(Belt_List.get(valences, tm_ix));
                    return /* NonterminalCapture */Block.__(1, [of_ast(lang, rules, valence[1], subtm)]);
                  } else {
                    return /* NonterminalCapture */Block.__(1, [of_ast(lang, rules, current_sort, subtm)]);
                  }
                }
                if (exit === 1) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        /* tuple */[
                          "ConcreteSyntax.ml",
                          390,
                          27
                        ]
                      ];
                }
                
              }));
        return mk_tree(current_sort, /* Operator */Block.__(0, [op_name]), children);
    case 1 : 
        exit = 1;
        break;
    case 2 : 
    case 3 : 
        exit$1 = 2;
        break;
    
  }
  if (exit$1 === 2) {
    switch (sort_name) {
      case "integer" : 
          if (current_sort[1].length !== 0) {
            exit = 1;
          } else if (tm.tag === 2) {
            throw [
                  BadSortTerm,
                  current_sort,
                  tm
                ];
          } else {
            var match$3 = tm[0];
            if (match$3.tag) {
              throw [
                    BadSortTerm,
                    current_sort,
                    tm
                  ];
            } else {
              var str = Bigint.to_string(match$3[0]);
              return mk_tree(current_sort, /* Primitive */Block.__(1, [/* Integer */0]), /* array */[mk_terminal_capture(str)]);
            }
          }
          break;
      case "sequence" : 
          var match$4 = current_sort[1];
          if (match$4.length !== 1) {
            exit = 1;
          } else {
            var sort = match$4[0];
            if (tm.tag === 2) {
              var children$1 = Belt_List.toArray(List.map((function (tm) {
                          return /* NonterminalCapture */Block.__(1, [of_ast(lang, rules, sort, tm)]);
                        }), tm[0]));
              return mk_tree(current_sort, /* Sequence */1, children$1);
            } else {
              throw [
                    BadSortTerm,
                    current_sort,
                    tm
                  ];
            }
          }
          break;
      case "string" : 
          if (current_sort[1].length !== 0) {
            exit = 1;
          } else if (tm.tag === 2) {
            throw [
                  BadSortTerm,
                  current_sort,
                  tm
                ];
          } else {
            var match$5 = tm[0];
            if (match$5.tag) {
              return mk_tree(current_sort, /* Primitive */Block.__(1, [/* String */1]), /* array */[mk_terminal_capture(match$5[0])]);
            } else {
              throw [
                    BadSortTerm,
                    current_sort,
                    tm
                  ];
            }
          }
          break;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    switch (tm.tag | 0) {
      case 1 : 
          return mk_tree(current_sort, /* Var */0, /* array */[mk_terminal_capture(tm[0])]);
      case 2 : 
      case 3 : 
          throw [
                BadSortTerm,
                current_sort,
                tm
              ];
      
    }
  }
  
}

function to_string(param) {
  var children_str = $$String.concat("", Belt_List.fromArray($$Array.map((function (param) {
                  switch (param.tag | 0) {
                    case 0 : 
                        var match = param[0];
                        return match[/* leading_trivia */1] + (match[/* content */0] + match[/* trailing_trivia */2]);
                    case 1 : 
                        return to_string(param[0]);
                    case 2 : 
                        return param[0];
                    
                  }
                }), param[/* children */4])));
  return param[/* leading_trivia */2] + (children_str + param[/* trailing_trivia */3]);
}

function remove_spaces(param) {
  var children$prime = Util.array_map_keep((function (param) {
          switch (param.tag | 0) {
            case 0 : 
                return /* TerminalCapture */Block.__(0, [param[0]]);
            case 1 : 
                return /* NonterminalCapture */Block.__(1, [remove_spaces(param[0])]);
            case 2 : 
                return undefined;
            
          }
        }), param[/* children */4]);
  return /* record */[
          /* sort */param[/* sort */0],
          /* node_type */param[/* node_type */1],
          /* leading_trivia */param[/* leading_trivia */2],
          /* trailing_trivia */param[/* trailing_trivia */3],
          /* children */children$prime
        ];
}

function to_ast(lang, tree) {
  var match = remove_spaces(tree);
  var children = match[/* children */4];
  var node_type = match[/* node_type */1];
  var exit = 0;
  if (typeof node_type === "number") {
    if (node_type === 0) {
      if (children.length !== 1) {
        exit = 1;
      } else {
        var match$1 = children[0];
        switch (match$1.tag | 0) {
          case 0 : 
              return /* Ok */Block.__(0, [/* Var */Block.__(1, [match$1[0][/* content */0]])]);
          case 1 : 
          case 2 : 
              exit = 1;
              break;
          
        }
      }
    } else {
      return Belt_Result.map(Curry._2(AA[/* traverse_array_result */2], (function (param) {
                        switch (param.tag | 0) {
                          case 0 : 
                              return /* Error */Block.__(1, ["TODO: message"]);
                          case 1 : 
                              return to_ast(lang, param[0]);
                          case 2 : 
                              return Pervasives.failwith("invariant violation: space found in to_ast sequence");
                          
                        }
                      }), children), (function (children$prime) {
                    return /* Sequence */Block.__(2, [Belt_List.fromArray(children$prime)]);
                  }));
    }
  } else if (node_type.tag) {
    if (children.length !== 1) {
      exit = 1;
    } else {
      var match$2 = children[0];
      switch (match$2.tag | 0) {
        case 0 : 
            var str = match$2[0][/* content */0];
            if (node_type[0]) {
              return /* Ok */Block.__(0, [/* Primitive */Block.__(3, [/* PrimString */Block.__(1, [str])])]);
            } else {
              try {
                return /* Ok */Block.__(0, [/* Primitive */Block.__(3, [/* PrimInteger */Block.__(0, [Bigint.of_string(str)])])]);
              }
              catch (exn){
                return /* Error */Block.__(1, ["failed to read integer literal"]);
              }
            }
        case 1 : 
        case 2 : 
            exit = 1;
            break;
        
      }
    }
  } else {
    var op_name = node_type[0];
    var children$prime = Curry._1(AA[/* sequence_array_result */1], Belt_Array.keepMap(children, (function (param) {
                switch (param.tag | 0) {
                  case 0 : 
                      return undefined;
                  case 1 : 
                      return scope_to_ast(lang, param[0]);
                  case 2 : 
                      return Pervasives.failwith("invariant violation: space found in to_ast");
                  
                }
              })));
    return Belt_Result.map(children$prime, (function (children$prime$prime) {
                  return /* Operator */Block.__(0, [
                            op_name,
                            Belt_List.fromArray(children$prime$prime)
                          ]);
                }));
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "ConcreteSyntax.ml",
            480,
            7
          ]
        ];
  }
  
}

function scope_to_ast(lang, tree) {
  var match = Belt_List.fromArray(Belt_Array.reverse(tree[/* children */4]));
  if (match) {
    var match$1 = to_ast(lang, /* record */[
          /* sort */tree[/* sort */0],
          /* node_type */tree[/* node_type */1],
          /* leading_trivia */tree[/* leading_trivia */2],
          /* trailing_trivia */tree[/* trailing_trivia */3],
          /* children : array */[match[0]]
        ]);
    if (match$1.tag) {
      return /* Error */Block.__(1, [match$1[0]]);
    } else {
      var body$prime = match$1[0];
      return Belt_Result.map(Util.traverse_list_result((function (param) {
                        switch (param.tag | 0) {
                          case 0 : 
                              return /* Ok */Block.__(0, [param[0][/* content */0]]);
                          case 1 : 
                              return /* Error */Block.__(1, ["expected binder name, got TODO"]);
                          case 2 : 
                              return Pervasives.failwith("invariant violation: space found in to_ast");
                          
                        }
                      }), match[1]), (function (binders$prime) {
                    return /* Scope */[
                            List.rev(binders$prime),
                            body$prime
                          ];
                  }));
    }
  } else {
    return /* Error */Block.__(1, ["scope_to_ast called on no children"]);
  }
}

var NonMatchingFixities = Caml_exceptions.create("ConcreteSyntax.NonMatchingFixities");

var MixedFixities = Caml_exceptions.create("ConcreteSyntax.MixedFixities");

function to_grammar(param) {
  var sort_rules = param[/* sort_rules */1];
  var terminal_rules = param[/* terminal_rules */0];
  Belt_MapString.keysToArray(terminal_rules);
  Belt_MapString.keysToArray(sort_rules);
  var terminal_names = Belt_MapString.fromArray(Belt_Array.mapWithIndex(Belt_MapString.keysToArray(terminal_rules), (function (i, name) {
              return /* tuple */[
                      name,
                      i
                    ];
            })));
  var nonterminal_names = Belt_MapString.set(Belt_MapString.fromArray(Belt_Array.mapWithIndex(Belt_MapString.keysToArray(sort_rules), (function (i, name) {
                  return /* tuple */[
                          name,
                          i
                        ];
                }))), "root", 0);
  var nonterminals = Belt_MapInt.set(Belt_MapInt.fromArray(Belt_Array.mapWithIndex(Belt_MapString.valuesToArray(sort_rules), (function (i, param) {
                  var productions = Belt_List.flatten(Belt_List.map(param[0][/* operator_rules */1], (function (operator_level) {
                              return Belt_List.map(operator_level, (function (param) {
                                            return Belt_List.map(param[0][/* tokens */0], (function (param) {
                                                          if (typeof param === "number") {
                                                            return /* Terminal */Block.__(0, [Util.get_option$prime("to_grammar: failed to get SPACE")(Belt_MapString.get(terminal_names, "SPACE"))]);
                                                          } else if (param.tag) {
                                                            var ntn = param[0];
                                                            return /* Nonterminal */Block.__(1, [Util.get_option$prime("to_grammar: failed to get " + ntn)(Belt_MapString.get(nonterminal_names, ntn))]);
                                                          } else {
                                                            var tn = param[0];
                                                            return /* Terminal */Block.__(0, [Util.get_option$prime("to_grammar: failed to get " + tn)(Belt_MapString.get(terminal_names, tn))]);
                                                          }
                                                        }));
                                          }));
                            })));
                  return /* tuple */[
                          i + 1 | 0,
                          /* record */[/* productions */productions]
                        ];
                }))), 0, /* record */[/* productions : :: */[
          /* :: */[
            /* Nonterminal */Block.__(1, [1]),
            /* [] */0
          ],
          /* [] */0
        ]]);
  return /* record */[
          /* nonterminals */nonterminals,
          /* num_terminals */Belt_MapString.size(terminal_rules),
          /* terminal_names */terminal_names,
          /* nonterminal_names */nonterminal_names
        ];
}

function production_info(nt_map, nonterminal_names, prod_num) {
  var nt_num = Util.get_option$prime("production_info: failed to get " + String(prod_num))(Belt_MutableMapInt.get(nt_map, prod_num));
  var f = function (param, nt_num$prime) {
    return nt_num$prime === nt_num;
  };
  var match = Belt_MapString.findFirstBy(nonterminal_names, f);
  var sort_name = match !== undefined ? match[0] : Pervasives.failwith("production_info: invariant violation: sort not found");
  return /* tuple */[
          /* Operator */Block.__(0, [sort_name]),
          /* SortAp */[
            sort_name,
            /* array */[]
          ]
        ];
}

function tree_of_parse_result(Lr0, nonterminal_names, sort_rules, str, root) {
  var str_pos = /* record */[/* contents */0];
  var str_len = str.length;
  var get_trivia = function (start_pos, end_pos) {
    var leading_trivia = str.slice(str_pos[0], start_pos);
    str_pos[0] = end_pos;
    var $$continue = true;
    while($$continue) {
      var match = str.charAt(str_pos[0]);
      var match$1;
      switch (match) {
        case "\n" : 
            match$1 = /* tuple */[
              false,
              true
            ];
            break;
        case " " : 
            match$1 = /* tuple */[
              true,
              false
            ];
            break;
        default:
          match$1 = /* tuple */[
            false,
            false
          ];
      }
      $$continue = str_pos[0] < str_len && match$1[0];
      if ($$continue) {
        str_pos[0] = str_pos[0] + 1 | 0;
      }
      
    };
    var trailing_trivia = str.slice(end_pos, str_pos[0]);
    return /* tuple */[
            leading_trivia,
            trailing_trivia
          ];
  };
  var go_nt = function (nt_name, param) {
    var production = param[/* production */0];
    var prod_num;
    prod_num = production.tag ? production[0] : Pervasives.failwith("invariant violation: go_nt received a terminal production");
    var match = production_info(Lr0[/* production_nonterminal_map */1], nonterminal_names, prod_num);
    var node_type = match[0];
    var match$1 = get_trivia(param[/* start_pos */2], param[/* end_pos */3]);
    var ctor_name;
    ctor_name = typeof node_type === "number" || node_type.tag ? Pervasives.failwith("invariant violation: got non-operator when handling a nonterminal") : node_type[0];
    var err = "tree_of_parse_result: failed to get " + nt_name;
    var match$2 = Util.get_option$prime(err)(Belt_MapString.get(sort_rules, nt_name));
    var maybe_op_rule = Belt_List.getBy(Belt_List.flatten(match$2[0][/* operator_rules */1]), (function (param) {
            var term_pattern = param[0][/* term_pattern */1];
            if (term_pattern.tag) {
              return true;
            } else {
              return ctor_name === term_pattern[0];
            }
          }));
    var tokens = maybe_op_rule !== undefined ? maybe_op_rule[0][/* tokens */0] : Pervasives.failwith("error: unable to find operator");
    return /* record */[
            /* sort */match[1],
            /* node_type */node_type,
            /* leading_trivia */match$1[0],
            /* trailing_trivia */match$1[1],
            /* children */Belt_List.toArray(Belt_List.map(Belt_List.zip(param[/* children */1], tokens), (function (param) {
                        var token = param[1];
                        var parse_result = param[0];
                        if (typeof token === "number") {
                          return /* SpaceCapture */Block.__(2, [" "]);
                        } else if (token.tag) {
                          return /* NonterminalCapture */Block.__(1, [go_nt(token[0], parse_result)]);
                        } else {
                          return /* TerminalCapture */Block.__(0, [go_t(token[0], parse_result)]);
                        }
                      })))
          ];
  };
  var go_t = function (t_name, param) {
    var end_pos = param[/* end_pos */3];
    var start_pos = param[/* start_pos */2];
    var match = get_trivia(start_pos, end_pos);
    var content = str.slice(start_pos, end_pos);
    return /* record */[
            /* content */content,
            /* leading_trivia */match[0],
            /* trailing_trivia */match[1]
          ];
  };
  return go_nt("root", root);
}

function lexer_of_desc(param) {
  return Belt_List.fromArray(Belt_Array.map(Belt_MapString.toArray(Belt_MapString.map(param[/* terminal_rules */0], regex_to_string)), (function (param) {
                    return /* tuple */[
                            param[1],
                            param[0]
                          ];
                  })));
}

function parse(desc, str) {
  try {
    var grammar = to_grammar(desc);
    var Lr0$prime = LrParsing.Lr0(/* module */[/* grammar */grammar]);
    var lexer = lexer_of_desc(desc);
    var match = Curry._2(Lr0$prime[/* lex_and_parse */36], lexer, str);
    if (match.tag) {
      var match$1 = match[0];
      if (match$1.tag) {
        var match$2 = match$1[0];
        return /* Error */Block.__(1, [Curry._2(Printf.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "parser error at character ",
                                /* Scan_get_counter */Block.__(21, [
                                    /* Char_counter */1,
                                    /* String_literal */Block.__(11, [
                                        ":\n",
                                        /* String */Block.__(2, [
                                            /* No_padding */0,
                                            /* End_of_format */0
                                          ])
                                      ])
                                  ])
                              ]),
                            "parser error at character %n:\n%s"
                          ]), match$2[0], match$2[1])]);
      } else {
        var match$3 = match$1[0];
        var end_pos = match$3[/* end_pos */1];
        var start_pos = match$3[/* start_pos */0];
        return /* Error */Block.__(1, [Curry._4(Printf.sprintf(/* Format */[
                            /* String_literal */Block.__(11, [
                                "lexical error at characters ",
                                /* Scan_get_counter */Block.__(21, [
                                    /* Char_counter */1,
                                    /* String_literal */Block.__(11, [
                                        " - ",
                                        /* Scan_get_counter */Block.__(21, [
                                            /* Char_counter */1,
                                            /* String_literal */Block.__(11, [
                                                " (",
                                                /* String */Block.__(2, [
                                                    /* No_padding */0,
                                                    /* String_literal */Block.__(11, [
                                                        "):\n",
                                                        /* String */Block.__(2, [
                                                            /* No_padding */0,
                                                            /* End_of_format */0
                                                          ])
                                                      ])
                                                  ])
                                              ])
                                          ])
                                      ])
                                  ])
                              ]),
                            "lexical error at characters %n - %n (%s):\n%s"
                          ]), start_pos, end_pos, str.slice(start_pos, end_pos), match$3[/* message */2])]);
      }
    } else {
      return /* Ok */Block.__(0, [tree_of_parse_result([
                      Lr0$prime[0],
                      Lr0$prime[1]
                    ], grammar[/* nonterminal_names */3], desc[/* sort_rules */1], str, match[0])]);
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === NonMatchingFixities) {
      return /* Error */Block.__(1, ["In sort " + (exn[1] + (": all fixities in a precedence level must be the same fixity (this is a limitation of Bison-style parsers (Jison in particular). The operators identified by [" + ($$String.concat(", ", exn[2]) + "] must all share the same fixity.")))]);
    } else if (exn[0] === MixedFixities) {
      return /* Error */Block.__(1, ["Found a mix of fixities -- all must be uniform " + (Pervasives.string_of_bool(exn[1]) + (" " + String(exn[2])))]);
    } else {
      throw exn;
    }
  }
}

exports.equivalent = equivalent;
exports.mk_tree = mk_tree;
exports.of_ast = of_ast;
exports.to_string = to_string;
exports.parse = parse;
exports.to_ast = to_ast;
exports.to_grammar = to_grammar;
exports.check_description_validity = check_description_validity;
exports.regex_piece_to_string = regex_piece_to_string;
/* AA Not a pure module */
